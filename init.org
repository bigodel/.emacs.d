#+TITLE: heartb1t's Emacs
#+BABEL: :cache yes :tangle "~/.emacs.d/init.el"
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:t

* TODO Redo all of the configuration

Redo the configuration trying to get rid of the maximum amount of things.


* About
:PROPERTIES:
:CUSTOM_ID: about
:END:

This is an Emacs configuration file written in [[http://orgmode.org][Org mode]]. It is heavily inspired
(almost a "fork") of Lars Tveito [[https://github.com/larstvei/dot-emacs][dot-emacs]] and Sasha Chua's [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs config]].

You might not want to simply copy and paste this into your configuration, I
recommend you get used to the defaults of Emacs since I'm using Evil-mode; and
also Emacs Lisp, so you can understand everything written in here. For a
introduction (a very comprehensive one) in elisp, refer to [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to
Programming in Emacs Lisp]] from the GNU Project website, or you could use the
built in info by typing =C-h i= and selecting "Emacs Lisp Intro". Also, as Sasha
Chua recommended, you could paste small portions of =elisp= code in the
=*scratch*= buffer and use the command =M-x eval buffer= to see what that code
might do without making the change permanent.

There also is a lot of packages that you might not need installed in here, so
check on the [[*General packages configuration][packages section]] of this file to see what are all of the packages I
use. If you like any package you can use =M-x install-package= to install it
yourself. You should also notice that I use the =use-package= package to manage
my packages and it's respective configurations, so you might need to install it
before using most of the stuff here.

If you're viewing the Org file, you can open source code blocks (those are the
ones in =BEGIN_SRC=) in a separate buffer by moving your point inside them and
typing =C-c '= which calls the function =org-edit-special=. This opens another
buffer in =emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the
changes. If you want to explore how functions work, use =M-x edebug-defun= to
set up debugging for that function, and then call it. You can learn more about
edebug in the [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp manual]].


* Configuration
:PROPERTIES:
:CUSTOM_ID: configuration
:END:

** Meta
:PROPERTIES:
:CUSTOM_ID: meta
:END:

All changes to the configuration should be done in =init.org=, not in =init.el=.
Any changes in the =init.el= will be overwritten by saving =init.org=.

Emacs can't load =.org=-files directly, but =org-mode= provides functions to
extract the code blocks and write them to a file. There are multiple ways of
handling this; like suggested by [[http://emacs.stackexchange.com/questions/3143/can-i-use-org-mode-to-structure-my/emacs-or-other-el-configuration-file][this StackOverflow post]], one could just use
=org-babel-load-file=. But here I use the approach suggested by Lars Tveito.

When this configuration is loaded for the first time, the =init.el= is the file
that is loaded. It looks like this:

#+BEGIN_SRC emacs-lisp :tangle no
  ;; This file replaces itself with the actual configuration at first run.

  ;; We can't tangle without org!
  (require 'org)
  ;; Open the configuration
  (find-file (concat user-emacs-directory "init.org"))
  ;; tangle it
  (org-babel-tangle)
  ;; load it
  (load-file (concat user-emacs-directory "init.el"))
  ;; finally byte-compile it
  (byte-compile-file (concat user-emacs-directory "init.el"))
#+END_SRC

It tangles the org-file, so that this file is overwritten with the actual
configuration.

There is no reason to track the =init.el= that is generated; by running the
following command =git= will not bother tracking it:

#+BEGIN_SRC sh :tangle no
  git update-index --assume-unchanged init.el
#+END_SRC

If one wishes to make changes to the repo-version of =init.el= start tracking
again with:

#+BEGIN_SRC sh :tangle no
  git update-index --no-assume-unchanged init.el
#+END_SRC

The =init.el= should (after the first run) mirror the source blocks in the
=README.org=. We can use =C-c C-v t= to run =org-babel-tangle=, which extracts the
code blocks from the current file into a source-specific file (in this case a
=.el=-file).

To avoid doing this each time a change is made we can add a function to the
=after-save-hook= ensuring to always tangle and byte-compile the =org=-document
after changes. I also made a function to update, in case the hook fails (which
has happened).

WARNING: This function might not work on your setup because I had to set the
=user-emacs-directory= variable to the location of my dotfiles. I use stow to
manage my dotfiles, it automatically creates symlinks from my configuration
files to the specified directory, that way I can keep all of my dotfiles inside
a single directory, making it easier for me to keep track of them via github and
makes the process of symlinking everything much easir (you just gotta type =stow
<program-name>=). If you want to learn more there is [[https://alexpearce.me/2016/02/managing-dotfiles-with-stow/][this]] link and [[http://brandon.invergo.net/news/2012-05-26-using-gnu-stow-to-manage-your-dotfiles.html][this]] link.

#+BEGIN_SRC emacs-lisp
  ;; I need to set this var because I use stow
  ;; If you have your .emacs.d in the default location
  ;; just set this var to "~/.emacs.d/"
  (setq user-emacs-directory "~/.emacs.d/")

  (defun tangle-init ()
    (interactive)
    "If the current buffer is init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (defun my/reload-config ()
    (interactive)
    "Reload the configuration for Emacs."
    (save-buffer)
    (org-babel-tangle-file (concat user-emacs-directory "init.org"))
    (byte-compile-file (concat user-emacs-directory "init.el")))

  (global-set-key (kbd "C-x r r") 'my/reload-config)

  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC

I'd like to keep a few settings private, so we load a =private.el= if it exists
after the init-file has loaded.

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook
    (lambda ()
      (let ((private-file (concat user-emacs-directory "private.el")))
        (when (file-exists-p private-file)
          (load-file private-file)))))
#+END_SRC

Some personal info.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Jo√£o Pedro de Amorim Paula"
        user-mail-address "jpedrodeamorim@gmail.com")
#+END_SRC

Server configuration. This is only define the directory to store the socket.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defvar server-socket-dir
    (and (featurep 'make-network-process '(:family local))
       (format "%s/emacs%d" (or (getenv "TMPDIR") "/tmp") (user-uid)))
    "The directory in which to place the server socket.
    If local sockets are not supported, this is nil.")
#+END_SRC


** [[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your text editor is malware]]
:PROPERTIES:
:CUSTOM_ID: malware
:END:

In this part I just followed the recommendations on this article, which I highly
recommend you to read it.

#+BEGIN_SRC emacs-lisp
  (setq tls-checktrust t)
#+END_SRC


** General packages configuration
:PROPERTIES:
:CUSTOM_ID: general-packages-configuration
:END:

I manage my packages with =package.el=, which comes pre-installed on Emacs 24+.
To load downloaded packages we need to initialize =package=. =cl= is a library
with some often handy Common Lisp functions, so we also initialize it in here.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (package-initialize)
#+END_SRC

Packages can be installed from various repos, here we add the two that I use
(which, frankly, is enough, since [[http://melpa.milkbox.net/#/][melpa]] is very large and well maintained).
There are also some packages that I need to load manually; I keep them stored in
=~/.emacs.d/elisp=, so I need to add it to my =load-path=.

#+BEGIN_SRC emacs-lisp
  (unless (assoc-default "melpa" package-archives)
    (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t))
  (unless (assoc-default "melpa-stable" package-archives)
    (add-to-list 'package-archives '("melpa-stable" . "https://stable.melpa.org/packages/") t))
  (unless (assoc-default "org" package-archives)
    (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))

  (add-to-list 'load-path "~/.emacs.d/elisp")
#+END_SRC

Use =M-x package-refresh-contents= to reload the list of packages after adding
these for the first time.

And here I check if =use-package= is installed. If not, I tell Emacs to install
it. There also is some configurations for it.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (setq use-package-verbose t)
  (setq use-package-always-ensure t)
  (require 'use-package)
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC

I also like to use =delight= for most of the minor modes, so let us install it.
Here I have a list of modes I want delighted and how to do that, but I also
specified that on (when I can remember) the =use-package= call.

#+BEGIN_SRC emacs-lisp
  (use-package delight
    :ensure t)

  (delight '((auto-fill-mode nil t)
             (eldoc-mode nil eldoc)
             (flyspell-mode nil flyspell)
             (abbrev-mode nil abbrev)
             (whitespace-mode nil whitespace)
             (yas-minor-mode nil yasnippet)
             (org-indent-mode nil org-indent)
             (auto-revert-mode nil autorevert)))

  (delight 'server-buffer-clients nil 'server)
  (delight 'auto-fill-function nil t)
#+END_SRC


** Custom functions
:PROPERTIES:
:CUSTOM_ID: custom-functions
:END:

*** Start and exit =eshell=
:PROPERTIES:
:CUSTOM_ID: start-and-exit-eshell
:END:

So, I copied a function from [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][this]] post to start =eshell= in a better way. It is
used [[A%20better%20way%20to%20start%20%3Deshell%3D][here]].

#+BEGIN_SRC emacs-lisp
  (defun my/eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                       default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))
#+END_SRC

*** Create missing directory
:PROPERTIES:
:CUSTOM_ID: create-missing-directory
:END:

This function asks to create a parent directory if you're trying to access a
file without one.

#+BEGIN_SRC emacs-lisp
  (defun my/create-non-existent-directory ()
        (let ((parent-directory (file-name-directory buffer-file-name)))
          (when (and (not (file-exists-p parent-directory))
                     (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
            (make-directory parent-directory t))))
  (add-to-list 'find-file-not-found-functions #'my/create-non-existent-directory)
#+END_SRC

*** Switch fonts
:PROPERTIES:
:CUSTOM_ID: switch-fonts
:END:

#+BEGIN_SRC emacs-lisp
  (defun my/switch-font (font)
    (interactive "Switch font (1. Inconsolata Nerd | 2. Terminus | 3. Hack Nerd | 4. Source Code Nerd | 5. Roboto Mono Nerd | 6. Monospace): ")
    (cond ((string= font "1") (set-frame-font (apply 'font-spec InconsolataNerd-font) nil t))
          ((string= font "2") (set-frame-font (apply 'font-spec Terminus-font) nil t))
          ((string= font "3") (set-frame-font (apply 'font-spec HackNerd-font) nil t))
          ((string= font "4") (set-frame-font (apply 'font-spec SourceCodeNerd-font) nil t))
          ((string= font "5") (set-frame-font (apply 'font-spec RobotoMonoNerd-font) nil t))
          ((string= font "6") (set-frame-font (apply 'font-spec Monospace-font) nil t))
          (t (message "Invalid option. Please choose a valide number."))))
#+END_SRC

*** Infer indentation style
:PROPERTIES:
:CUSTOM_ID: infer-indentation-style
:END:

This function I got from the EmacsWiki page on [[https://www.emacswiki.org/emacs/NoTabs][spaces instead of tabs]]. It is a
pretty simple function that verifies if the number or spaces is bigger or
smaller than the number of tabs and chooses the appropriate option.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/infer-indentation-style ()
    ;; if our source file uses tabs, we use tabs, if spaces spaces, and if
    ;; neither, we use the current indent-tabs-mode
    (let ((space-count (how-many "^  " (point-min) (point-max)))
          (tab-count (how-many "^\t" (point-min) (point-max))))
      (if (> space-count tab-count) (setq indent-tabs-mode nil))
      (if (> tab-count space-count) (setq indent-tabs-mode t))))
#+END_SRC

*** Insert line above and below without moving the cursor
:PROPERTIES:
:CUSTOM_ID: insert-line-above-and-below
:END:

#+begin_src emacs-lisp :tangle yes
  (defun insert-line-below ()
    "Insert a line below the cursor."
    (interactive)
    (let ((current-point (point)))
      (move-end-of-line 1)
      (open-line 1)
      (goto-char current-point)))

  (defun insert-line-above ()
    "Insert a line above the cursor."
    (interactive)
    (let ((current-point (point)))
      (move-beginning-of-line 1)
      (newline-and-indent)
      (indent-according-to-mode)
      (goto-char current-point)
      (forward-char)))

  (global-set-key (kbd "C-S-n") 'insert-line-below)
  (global-set-key (kbd "C-S-o") 'insert-line-above)
#+end_src

*** Toggle between vertical and horizontal split
:PROPERTIES:
:CUSTOM_ID: toggle-vertical-horizontal-split
:END:

This function I got from a [[https://stackoverflow.com/questions/2081577/setting-emacs-split-to-horizontal][StackOverflow post]] when I was looking for a way to
set the default split to be vertical, because I use the =C-c o= on helm to open
a new file or a buffer on another window, but that would always open a
horizontal window. The functions lets me toggle between horizontal and vertical
split in the current window; from the post: "/If you got two windows in one
frame, and you want to change the layout from vertical to horizontal or vice/
/versa/".

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/toggle-window-split ()
    (interactive)
      (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
              (next-win-buffer (window-buffer (next-window)))
              (this-win-edges (window-edges (selected-window)))
              (next-win-edges (window-edges (next-window)))
              (this-win-2nd
               (not (and (<= (car this-win-edges)
                          (car next-win-edges))
                      (<= (cadr this-win-edges)
                          (cadr next-win-edges)))))
           (splitter
            (if (= (car this-win-edges)
                   (car (window-edges (next-window))))
                'split-window-horizontally
              'split-window-vertically)))
      (delete-other-windows)
      (let ((first-win (selected-window)))
        (funcall splitter)
        (if this-win-2nd (other-window 1))
        (set-window-buffer (selected-window) this-win-buffer)
        (set-window-buffer (next-window) next-win-buffer)
        (select-window first-win)
        (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Insert unicode character

This is just a helper function to use with a hydra (defined in the [[id:hydra][hydra]] section
ahead) to insert unicode characters.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/insert-unicode (unicode-name)
    "Same as: C-x 8 Enter UNICODE-NAME."
    (insert-char (cdr (assoc-string unicode-name (ucs-names)))))
#+END_SRC


** TRAMP
:PROPERTIES:
:CUSTOM_ID: tramp
:END:

Here is some configuration regarding TRAMP, the "Transparent Remote (file)
Access, Multiple Protocol". It allows me to access remote files form inside my
current Emacs, that is, I can use my local Emacs configuration to edit remote
files seamlessly.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq tramp-default-method "ssh")

  ;; From the TRAMP FAQ
  (setq remote-file-name-inhibit-cache nil)
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                      vc-ignore-dir-regexp
                      tramp-file-name-regexp))
  (setq tramp-verbose 1)

  (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
#+END_SRC


** Evil-mode
:PROPERTIES:
:CUSTOM_ID: evil-mode
:END:

Here is the thing that made me decide to change to Emacs. I love the modal
editing of Vim, but Vim couldn't give me all I wanted in terms of functionality
(simple stuff like auto-completion was a pain in the ass to setup compared to
other editors) and plus it was getting way too slow because of the many changes
I was making and tons of packages I needed to install. When I saw the power of
Emacs I was sold, but I didn't want to abandon the editing style of Vim, and
that's when I came across Evil-mode and decided that I was going to give Emacs a
try.

And just for the record, I did use Emacs with its default configuration for
about two months to get the hang of it, but I just find Vim's modal editing
superior (might be the muscle memory though).

But there are also a bunch of other packages to go along with Evil to make it
more like Vim, for example =evil-surround= to let us have the surround text
object; with this package we can do =ci"= to change some text inside double
quotes.

There also is a project, called [[https://github.com/jojojames/evil-collection][=evil-collection=]] that aims to "evilize" the
parts of Emacs that do not have evil keybindings by default. If you want to use
evil bindings by default on the minibuffer you'll need to setup
=evil-collection-setup-minibuffer= to t yourself, it is disabled by default
because many users find it confusing.

Here's a list of all the evil packages I have:

  + =evil-surround=
  + =evil-commentary=
  + =evil-leader=
  + =evil-jumper=
  + =evil-org=
  + =evil-magit=

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-shift-width 4
          evil-regexp-search t
          evil-search-wrap t
          evil-want-C-i-jump t
          evil-want-C-u-scroll t
          evil-want-fine-undo nil
          evil-want-integration nil)
    :config
    (evil-mode 1)

    (use-package evil-surround
      :ensure t
      :config
      (global-evil-surround-mode))

    (use-package evil-commentary
      :ensure t
      :delight
      :config
      (evil-commentary-mode))

    (use-package evil-leader
      :ensure t
      :config
      (global-evil-leader-mode))

    (use-package evil-org
      :ensure t
      :delight
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
        (lambda ()
          (evil-org-set-key-theme))))

    (use-package evil-magit
      :ensure t
      :config
      (evil-magit-init)))
#+END_SRC


** Helm
:PROPERTIES:
:CUSTOM_ID: helm
:END:

This is also one of the packages I couldn't live without, it provides better
interfaces and completion for almost everything that Emacs does. From the
[[https://github.com/emacs-helm/helm/wiki#general-concept]["General concept"]] section on their wiki:

#+BEGIN_QUOTE
People often think helm is just something like [[https://www.emacswiki.org/emacs/InteractivelyDoThings][=ido=]] but displaying
completion in a vertical layout instead of an horizontal one, it is not,
helm is much more powerful than that.

  + Helm is able to complete multiple lists dispatched in different sources against a pattern.

  + Helm allows executing an unlimited number of actions on candidates.

  + Helm allows marking candidates to execute chosen action against this set of candidates.
#+END_QUOTE

*** General configuration
:PROPERTIES:
:CUSTOM_ID: helm-general-configurations
:END:

Here we just install the main helm package, but helm has much more than that its
main package. For a more detailed in-depth look into Helm, checkout [[http://tuhdo.github.io/helm-intro.html][this]] post.

#+BEGIN_SRC emacs-lisp
  (use-package helm
    :ensure t
    :delight
    :config
    (require 'helm-config)

    (use-package helm-c-yasnippet
        :ensure t
        :delight)

    ;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
    ;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
    ;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
    (global-set-key (kbd "C-c h") 'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))

    (global-set-key (kbd "C-h a") #'helm-apropos)
    (global-set-key (kbd "C-x C-b") #'helm-mini)
    (global-set-key (kbd "C-x b") #'helm-buffers-list)
    (global-set-key (kbd "M-y") #'helm-show-kill-ring)
    (global-set-key (kbd "M-x") #'helm-M-x)
    (global-set-key (kbd "C-x C-f") #'helm-find-files)
    (global-set-key (kbd "C-c h o") #'helm-occur)
    (global-set-key (kbd "C-c y") #'helm-yas-complete)
    (global-set-key (kbd "C-c h Y") #'helm-yas-create-snippet-on-region)
    (global-set-key (kbd "C-c h SPC") #'helm-all-mark-rings)
    (global-set-key (kbd "M-:") #'helm-eval-expression-with-eldoc)

    (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
    (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

    (setq helm-candidate-number-limit 100
          helm-auto-resize-mode t
          helm-split-window-inside-p t ; open helm buffer inside current window, not occupy whole other window
          helm-move-to-line-cycle-in-source nil ; move to end or beginning of source when reaching top or bottom of source.
          helm-ff-file-name-history-use-recentf t
          helm-mode-fuzzy-match t
          helm-completion-in-region-fuzzy-match t
          ;; From https://gist.github.com/antifuchs/9238468
          helm-idle-delay 0.0           ; update fast sources immediately (doesn't).
          helm-input-idle-delay 0.01    ; this actually updates things reeeelatively quickly.
          helm-yas-display-key-on-candidate t
          helm-quick-update t
          helm-ff-skip-boring-files t)

    (helm-mode 1))
#+END_SRC

*** Helm extensions
:PROPERTIES:
:CUSTOM_ID: helm-extensions
:END:

There are also plenty of other helm packages that I installed, here is another
list:

  + =helm-projectile=
  + =helm-themes=
  + =helm-flycheck=
  + =helm-flyspell=
  + [[https://github.com/tmalsburg/helm-bibtex][=helm-bibtex=]]
  + =helm-company=
  + =helm-ghc=
  + =helm-tramp=
  + =helm-gtags=

#+BEGIN_SRC emacs-lisp
  (use-package helm-projectile
    :ensure t
    :bind
    (("C-S-P" . helm-projectile-switch-project)
     :map evil-normal-state-map
     ("C-p" . helm-projectile)))

  (use-package helm-themes
    :ensure t)

  (use-package helm-flycheck
    :ensure t)

  (use-package helm-flyspell
    :ensure t)

  (use-package helm-bibtex
    :ensure t
    :config
    (setq bibtex-completion-bibliography
          '("~/Templates/LaTeX/index.bib")))

  (use-package helm-company
    :ensure t)

  (use-package helm-ghc
    :ensure t
    :config
    (add-hook 'haskell-mode-hook
              (lambda () (define-key haskell-mode-map (kbd "C-c ?") 'helm-ghc-errors))))

  (use-package helm-tramp
    :ensure t
    :config
    (global-set-key (kbd "C-c s") 'helm-tramp))

  (use-package helm-gtags
    :ensure t
    :delight
    :init
    (setq helm-gtags-ignore-case t
          helm-gtags-auto-update t
          helm-gtags-use-input-at-cursor t
          helm-gtags-pulse-at-cursor t
          helm-gtags-prefix-key "\C-cg"
          helm-gtags-suggested-key-mapping t)
    :config
    ;; Enable helm-gtags-mode
    (add-hook 'dired-mode-hook 'helm-gtags-mode)
    (add-hook 'eshell-mode-hook 'helm-gtags-mode)
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
    (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
    (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key evil-normal-state-map (kbd "M-.") 'helm-gtags-dwim)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))
#+END_SRC


** Org-mode
:PROPERTIES:
:CUSTOM_ID: org-mode
:END:

*** Modules
:PROPERTIES:
:CUSTOM_ID: org-modules
:END:

Since =org-mode= has been installed before, because we kind need it for our
whole config setup to run, here we only install and configure all of its
auxiliary packages.

Here is some babel packages.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ox-pandoc
    :ensure t)
#+END_SRC

This is used to make beautiful slide presentations.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-tree-slide
    :ensure t
    :config
    (define-key org-mode-map (kbd "<f8>") 'org-tree-slide-mode)
    (define-key org-mode-map (kbd "S-<f8>") 'org-tree-slide-skip-done-toggle))
#+END_SRC

This module is used to manage citations with =org-mode=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-ref
    :ensure t
    :config
    (setq reftex-default-bibliography '("~/docs/bib/index.bib"))

    ;; see org-ref for use of these variables
    (setq ;; org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
          org-ref-default-bibliography '("~/docs/bib/index.bib"))
          ;; org-ref-pdf-directory "~/Dropbox/bibliography/bibtex-pdfs/")

    (setq bibtex-completion-bibliography "~/docs/bib/index.bib")
    ;; bibtex-completion-library-path "~/Dropbox/bibliography/bibtex-pdfs"
    ;; bibtex-completion-notes-path "~/Dropbox/bibliography/helm-bibtex-notes")
    )
#+END_SRC

*** Configuration
:PROPERTIES:
:CUSTOM_ID: org-configuration
:END:

Default configuration regarding =org-mode=. Here is where I set most of the
configuration with =setq='s.

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(org-load-modules-maybe t))
  (eval-after-load "org"
    '(require 'ox-md nil t))

  ;; default options for all output formats
  (setq org-pandoc-options '((standalone . t)))
  ;; cancel above settings only for 'docx' format
  (setq org-pandoc-options-for-docx '((standalone . nil)))
  ;; special settings for beamer-pdf and latex-pdf exporters
  (setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
  (setq org-pandoc-options-for-latex-pdf '((pdf-engine . "xelatex")))

  (setq org-export-backends '(org latex calendar html ascii)
        org-highlight-latex-and-related '(latex)
        org-startup-indented t
        org-return-follows-link t
        org-pretty-entities t
        org-src-fontify-natively t
        org-src-window-setup 'current-window
        org-src-tab-acts-natively t
        org-list-allow-alphabetical t
        org-hide-emphasis-markers nil
        org-image-actual-width nil)

  ;; Using %s on the link substitutes the %s with a string on the :tag after the
  ;; linkword. The %h will url-encode the tag.
  (setq org-link-abbrev-alist
        '(("githome"   . "https://github.com/heartb1t")))
  ;; ("notes" . "~/Documents/Org/notes.org::#%s")

  (define-key org-mode-map (kbd "C-c l") 'org-store-link)
#+END_SRC

This is to use actual bullets "‚àô" for org lists, and change the ellipsis.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; This tries to find a + or - or * at the beginning of the line and replaces
  ;; it with the character at the end
  (font-lock-add-keywords 'org-mode
                          '(("^ +\\([-*+]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "‚àô"))))))

  (setq org-ellipsis "...") ;; ‚Ä¢‚Ä¢‚Ä¢ ÓóÖ Óåì ‚¨é ‚§∑
#+END_SRC

*** Babel
:PROPERTIES:
:CUSTOM_ID: org-babel
:END:

Here I put some settings for babel, the code system for Org-mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (org-babel-do-load-languages
   'org-babel-load-languages '((emacs-lisp . t)
                               (C . t)
                               (python . t)
                               (sh . t)
                               (shell . t)
                               (haskell . t)
                               (makefile . t)
                               (latex . t)))
#+END_SRC

*** Htmlize
:PROPERTIES:
:CUSTOM_ID: htmlize
:END:

I need htmlize to export to html.

#+BEGIN_SRC emacs-lisp
  (use-package htmlize
    :ensure t)
#+END_SRC


** Eshell
:PROPERTIES:
:CUSTOM_ID: start-and-exit-eshell
:END:

=eshell= is the Emacs Shell, a shell interpreter (a REPL) implemented in Emacs
Lisp. It is very well integrated with Emacs, and so it is my preferred way of
interacting with a terminal while I'm doing my editing. It also integrates very
well with =evil-mode= which is a nice added bonus.

*** Disable line number
:PROPERTIES:
:CUSTOM_ID: eshell-disable-line-number
:END:

Disable line number on the =eshell= buffer.

#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook
    (lambda ()
      (nlinum-mode -1)))
#+END_SRC

*** Use =eshell= to run quick commands
:PROPERTIES:
:CUSTOM_ID: eshell-run-quick-commands
:END:

I'd rather also use =eshell= instead of the regular interpreter when I type
=M-!=.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-!") 'eshell-command)
#+END_SRC

*** A better way to start =eshell=
:PROPERTIES:
:CUSTOM_ID: a-better-way-of-start-eshell
:END:

Since I copied this from [[http://www.howardism.org/Technical/Emacs/eshell-fun.html][this]] post, I might as well copy its description.

#+BEGIN_QUOTE
Since my workflow is driven from Emacs, shells are temporary. I pop out to a
shell for a few commands, and then return to my work. When I say pop out to the
shell, I use the following function which creates a buffer-specific window in
the lower third portion and start Eshell (which picks up that buffer‚Äôs
directory).
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-!") 'my/eshell-here)
  (define-key evil-normal-state-map (kbd "!") 'my/eshell-here)
  (define-key evil-visual-state-map (kbd "!") 'my/eshell-here)
  (define-key evil-motion-state-map (kbd "!") 'my/eshell-here)
#+END_SRC


** General configuration
:PROPERTIES:
:CUSTOM_ID: general-packages-configuration
:END:

*** Sane defaults
:PROPERTIES:
:CUSTOM_ID: sane-defaults
:END:

These are some configurations I consider to be more sane defaults.

#+BEGIN_SRC emacs-lisp
  (setq auto-revert-interval 1            ; Refresh buffers fast
        custom-file (make-temp-file "")   ; Discard customzation's
        default-input-method "portuguese-prefix"
        echo-keystrokes 0.1               ; Show keystrokes asap
        inhibit-startup-message t         ; No splash screen please
        initial-scratch-message nil       ; Clean scratch buffer
        recentf-max-saved-items 100       ; Show more recent files
        ring-bell-function 'ignore        ; Quiet
        sentence-end-double-space nil)    ; No double space
#+END_SRC

Some variables are buffer-local, so changing them using =setq= will only change
them in a single buffer. Using =setq-default= we change the buffer-local
variable‚Äôs default value.

#+BEGIN_SRC emacs-lisp
  (setq-default c-basic-offset 'tab-width     ; Default C indentation
                lisp-indent-offset 'tab-width ; Default lisp indentation
                indent-tabs-mode nil)         ; Spaces instead of tabs
#+END_SRC

By default the narrow-to-region command is disabled and issues a warning,
because it might confuse new users. I find it useful sometimes, and don‚Äôt want
to be warned.

#+BEGIN_SRC emacs-lisp
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

Automatically revert buffers when the file is changed externally.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

Set the <tab> key to actually insert a tab. This setting behaves as expected
with =evil-mode=, that means that it only inserts a tab on =evil-insert-state=;
also, with packages like =yasnippet= the tab actually triggers the snippet. For
more on emacs and tabs, refer to [[http://www.pement.org/emacs_tabs.htm][Understanding GNU Emacs and Tabs]].

#+BEGIN_SRC emacs-lisp
  ;;(global-set-key (kbd "<tab>") 'tab-to-tab-stop)
#+END_SRC

Save the cursor position on each file.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; remember cursor position, for emacs 25.1 or later
  (save-place-mode 1)
#+END_SRC

*** Default browser
:PROPERTIES:
:CUSTOM_ID: default-browser
:END:

Set the default browser to be =eww=.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'eww-browse-url)

  ;; remove line number on the eww buffer
  (add-hook 'eww-mode-hook
    (lambda ()
      (nlinum-mode -1)))

  ;; use b to go back a word and M-b to set a bookmark
  (add-hook 'eww-mode-hook
            (lambda ()
              (local-set-key (kbd "b") 'evil-backward-word-begin)
              (local-set-key (kbd "M-b") 'eww-add-bookmark)))
#+END_SRC

*** Hippie expand
:PROPERTIES:
:CUSTOM_ID: hippie-expand
:END:

[[https://www.emacswiki.org/emacs/HippieExpand][=hippie-expand=]] is [[https://www.emacswiki.org/emacs/DynamicAbbreviations][=dabbrev=]] on steroids. But I also want to use
[[https://www.emacswiki.org/emacs/AbbrevMode][=abbrev-mode=]] globally.

#+BEGIN_SRC emacs-lisp :tangle yes
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))

  (global-set-key (kbd "M-/") #'hippie-expand)

  (setq abbrev-file-name             ;; tell emacs where to read abbrev
        "~/.emacs.d/abbrev_defs")    ;; definitions from..

  (setq save-abbrevs 'silently)

  (setq-default abbrev-mode t)
#+END_SRC

*** Backup file
:PROPERTIES:
:CUSTOM_ID: backup-file
:END:

By default, Emacs saves a backup file on the directory of the file
you're working on; it is a file of the same of the one you're editing,
but with a ~ at the end. Many people don't like that, myself included,
but I still want to have the backup files just in case (it has saved
me already), so I tell Emacs to save it on =~/.emacs.d/backups=.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

But I'm quite paranoid, so I have a lot of backup configuration.

#+BEGIN_SRC emacs-lisp
  (setq backup-by-copying t               ; don't clobber symlinks
        version-control t                 ; version numbers for backup files
        delete-old-versions t             ; delete excess backup files silently
        kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
        kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
        auto-save-default t               ; auto-save every buffer that visits a file
        auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
        auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
        vc-make-backup-files t
        auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

*** History
:PROPERTIES:
:CUSTOM_ID: history
:END:

This is from Sasha's config, which in turn is from [[http://www.wisdomandwonder.com/wp-content/uploads/2014/03/C3F.html][Creation and conservation of
computer files (C3F)]]

#+BEGIN_SRC emacs-lisp
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC

*** Window configuration
:PROPERTIES:
:CUSTOM_ID: window-configuration
:END:

I come from Vim, so I never liked the =tool-bar=, =menu-bar= and =scroll-bar=,
and I really tried to like it and use, but couldn't find it useful, so I
deactivate it. And I also don't like the blinking cursor.

#+BEGIN_SRC emacs-lisp
  (dolist (mode
         '(tool-bar-mode                ; No toolbars, more room for text
           menu-bar-mode                ; No menu bar, more room for text
           scroll-bar-mode              ; No scroll bars either
           blink-cursor-mode))          ; The blinking cursor gets old
    (funcall mode 0))
#+END_SRC

Here I remove the right fringe just because I haven't needed it yet.

#+begin_src emacs-lisp :tangle yes
  (fringe-mode '(1 . 0))
#+end_src

Configuration regarding the splitting of windows. The functions used here are in
the [[Custom%20functions][Custom functions]] part of this file.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; C-x 4 t 'toggle-window-split
  (define-key ctl-x-4-map "t" 'my/toggle-window-split)
#+END_SRC

*** Charset
:PROPERTIES:
:CUSTOM_ID: charset
:END:

This is just a charset definition.

#+BEGIN_SRC emacs-lisp
  (set-language-environment 'utf-8)
  (setq locale-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

*** Color theme
:PROPERTIES:
:CUSTOM_ID: color-theme
:END:

My color theme.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package color-theme-sanityinc-tomorrow
    :ensure t)

  (load-theme 'sanityinc-tomorrow-bright t)
#+END_SRC

*** Cursor color mode
:PROPERTIES:
:CUSTOM_ID: cursor-color-mode
:END:

This is a package to change the cursor color according to the color of the text
the cursor is in.

#+BEGIN_SRC emacs-lisp
  (use-package smart-cursor-color
    :delight
    :ensure t
    :config
    (smart-cursor-color-mode 1))
#+END_SRC

*** Font configuration
:PROPERTIES:
:CUSTOM_ID: font-configuration
:END:

Here I have some variables to define some fonts. I also have a function to
easily switch fonts which you can checkout [[Custom functions][here]]. I also changed the default way
of increasing and decreasing font size on the fly.

#+BEGIN_SRC emacs-lisp
  (defvar InconsolataNerd-font '(:family "Inconsolata Nerd Font" :size 20))
  (defvar Terminus-font '(:family "Terminus" :size 22))
  (defvar HackNerd-font '(:family "Knack Nerd Font" :size 18))
  (defvar SourceCodeNerd-font '(:family "SauceCodePro Nerd Font" :size 13))
  (defvar RobotoMonoNerd-font '(:family "RobotoMono Nerd Font" :size 18))
  (defvar Monospace-font '(:family "monospace" :size 18))

  (add-to-list 'default-frame-alist '(font . "Terminus-16"))

  ;; increase, decrease and adjust font size
  (global-set-key (kbd "C-+") 'text-scale-increase)
  (global-set-key (kbd "C--") 'text-scale-decrease)
  (global-set-key (kbd "C-0") 'text-scale-adjust)
#+END_SRC

*** COMMENT Mode line
:PROPERTIES:
:CUSTOM_ID: mode-line
:END:

Here is the configuration regarding the mode line. I install a package called
=all-the-icons= here; it gives me, well, all the icons.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons
    :demand
    :init
    (progn (defun my/modeline-github-vc ()
             (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
               (concat
                (propertize (format " %s" (all-the-icons-octicon "git-branch"))
                            'face `(:height 1 :family ,(all-the-icons-octicon-family))
                            'display '(raise 0))
                (propertize (format " %s" branch)))))

           (defun my/modeline-svn-vc ()
             (let ((revision (cadr (split-string vc-mode "-"))))
               (concat
                (propertize (format " %s" (all-the-icons-faicon "cloud"))
                            'face `(:height 1)
                            'display '(raise 0))
                (propertize (format " %s" revision) 'face `(:height 0.9)))))

           (defvar mode-line-my/vc
             '(:propertize
               (:eval (when vc-mode
                        (cond
                         ((string-match "Git[:-]" vc-mode) (my/modeline-github-vc))
                         ((string-match "SVN-" vc-mode) (my/modeline-svn-vc))
                         (t (format "%s" vc-mode)))))
               face mode-line-directory)
             "Formats the current directory.")

           ;; (setcar mode-line-position "")
           )
    :config
    (progn (setq-default mode-line-format
                         (list
                          "  "
                          mode-line-mule-info
                          mode-line-modified
                          mode-line-client
                          mode-line-frame-identification
                          mode-line-buffer-identification
                          mode-line-remote
                          "  "
                          mode-line-position
                          mode-line-my/vc
                          "  "
                          mode-line-modes
                          "  "
                          '(:eval (format "[%s]" (projectile-project-name)))
                          '(:eval (replace-regexp-in-string "FlyC" "ùìï" (flycheck-mode-line-status-text)))))))
#+END_SRC

*** White space handling
:PROPERTIES:
:CUSTOM_ID: white-space-handling
:END:

Handle whites paces on save and only highlight undesirable white spaces.

#+BEGIN_SRC emacs-lisp
  (use-package whitespace
    :init
    (dolist (hook '(python-mode-hook text-mode-hook))
      (add-hook hook #'whitespace-mode))
    (add-hook 'before-save-hook #'whitespace-cleanup)
    :config
    (setq whitespace-line-column 80) ;; limit line length
    (setq whitespace-style '(face tabs empty trailing lines-tail)))
#+END_SRC

*** Change "yes or no" prompt to "y or n"
:PROPERTIES:
:CUSTOM_ID: change-yes-or-no-to-y-or-n
:END:

Pretty self explanatory.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Smooth scrolling
:PROPERTIES:
:CUSTOM_ID: smooth-scrolling
:END:

This is a something I got from [[https://www.emacswiki.org/emacs/SmoothScrolling][EmacsWiki's page on smooth scrolling]].

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil))
        mouse-wheel-progressive-speed nil
        mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+END_SRC

*** Undo tree
:PROPERTIES:
:CUSTOM_ID: undo-tree
:END:

As Sasha said, some people struggle with Emacs' undo style, and I'm one of
those, so I use her config for the =undo-tree= package.

This lets you use =C-x u= (=undo-tree-visualize=) to see the changes you've made
and undo or redo certain changes.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :delight
    :config
    (progn
      (global-undo-tree-mode)
      (setq undo-tree-visualizer-timestamps t)
      (setq undo-tree-visualizer-diff t)))
#+END_SRC

*** Folding
:PROPERTIES:
:CUSTOM_ID: folding
:END:

If you're a die hard fan of the vim style of fold, you could look into
[[https://github.com/mrkkrp/vimish-fold][=vimish-fold=]] and also [[https://github.com/alexmurray/evil-vimish-fold][=evil-vimish-fold=]] because if you love vim's fold style
so much you are probably using =evil-mode=.

#+BEGIN_SRC emacs-lisp
  (use-package vimish-fold
    :ensure t
    :delight
    :config
    (add-to-list 'evil-fold-list '((vimish-fold-mode)
                                 :open-all   vimish-fold-unfold-all
                                 :close-all  nil
                                 :toggle     vimish-fold-toggle
                                 :open       vimish-fold-unfold
                                 :open-rec   nil
                                 :close      vimish-fold))

    (define-key evil-visual-state-map (kbd "zf") #'vimish-fold)
    (define-key evil-normal-state-map (kbd "zf") #'vimish-fold)
    (define-key evil-visual-state-map (kbd "zd") #'vimish-fold-delete)
    (define-key evil-normal-state-map (kbd "zd") #'vimish-fold-delete))
#+END_SRC

*** Help with shortcuts
:PROPERTIES:
:CUSTOM_ID: help-with-shortcuts
:END:

I'm pretty forgetful, and even though I've using something for quite some time,
I tend to forget some less used shortcuts (and even some I use quite often), so
I use =guide-key= to help me remember stuff.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :delight
    :config
    (which-key-mode)
    (which-key-setup-side-window-bottom))
#+END_SRC

*** Line number mode
:PROPERTIES:
:CUSTOM_ID: line-number-mode
:END:

Since I use Evil mode, I like having my line number column at the side, so I use
=linum-mode= for it. I also made it show me relative numbers along side real
line number because that is pretty handy when you are using Vim commands.

#+BEGIN_SRC emacs-lisp
  (use-package nlinum
    :ensure t
    :delight
    :config
    (global-nlinum-mode)
    (setq nlinum-format "%d "))
#+END_SRC

*** Dired
:PROPERTIES:
:CUSTOM_ID: dired
:END:

This is where I keep my configuration for Dired, the Emacs file manager. I try
to keep it simple, but I don't think I succeeded.

#+BEGIN_SRC emacs-lisp
  (require 'dired)
  ;; allow dired to delete or copy dir
  (setq dired-recursive-copies (quote always) ;; ‚Äúalways‚Äù means no asking
        dired-recursive-deletes (quote top))  ;; ‚Äútop‚Äù means ask once

  (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file) ;; was dired-advertised-find-file

  (define-key dired-mode-map (kbd "^") (lambda () (interactive) (find-alternate-file "..")))  ; was dired-up-directory

  (use-package dired-sidebar
    :bind (("C-c d" . dired-sidebar-toggle-sidebar))
    :ensure t
    :commands (dired-sidebar-toggle-sidebar)
    :config
    (setq dired-sidebar-subtree-line-prefix "  |")
    (cond
     ((eq system-type 'gnu/linux)
      (if (display-graphic-p)
          (setq dired-sidebar-theme 'icons)
        (setq dired-sidebar-theme 'ascii))
      (setq dired-sidebar-face '(:family "Terminus" :height 140))))

    (setq dired-sidebar-use-term-integration t)
    (setq dired-sidebar-use-custom-font t))

  (add-hook 'dired-mode-hook
            (lambda ()
              (nlinum-mode -1)))
#+END_SRC

*** Flyspell
:PROPERTIES:
:CUSTOM_ID: flyspell
:END:

Activate =flyspell= on =text-mode= files.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-flyspell)
#+END_SRC

But we can also use =flypsell= for programming, with =flyspel-prog-mode=, and it
only verifies comments and strings.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+END_SRC

*** Jumping
:PROPERTIES:
:CUSTOM_ID: jumping
:END:

I use =avy= to walk around on the screen. I mapped =SPC= on =evil-normal-state=
(which is Vim's normal mode) to activate it.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :config
    (define-key evil-normal-state-map (kbd "SPC") 'avy-goto-word-or-subword-1))
#+END_SRC

*** PDF
:PROPERTIES:
:CUSTOM_ID: split-the-screen-and-go-to-next-buffer
:END:

I use [[https://github.com/politza/pdf-tools][=pdf-tools=]] to overlap the =doc-view-mode= because it is really good.

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :magic ("%PDF" . pdf-view-mode)
    :config
    (pdf-tools-install))

  ;; Disble linum-mode and split horizontally in pdf-view-mode
  (add-hook 'pdf-view-mode-hook
    (lambda()
      (nlinum-mode -1)))

  ;; Split horizontally on LaTeX-mode
  (defun my/latex-mode-hook ()
    (setq split-height-threshold nil
          split-width-threshold 0))
  (add-hook 'LaTeX-mode-hook 'my/latex-mode-hook)

  ;; Use pdf-tools to open PDF files
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-view-program-list '(("pdf-tools" "TeX-pdf-tools-sync-view"))
        TeX-source-correlate-start-server t)

  ;; Update PDF buffers after successful LaTeX runs
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC

*** Presentations
:PROPERTIES:
:CUSTOM_ID: presentations
:END:

Yes, it is possible to do presentations on Emacs. One of the things that got me
into Emacs was [[https://www.youtube.com/watch?v%3DB6jfrrwR10k][this video]], where Howard Abrams makes the whole presentation
about Emacs inside it. To do that, he had to create many tools (like you're
intended to) and he figured it would be very useful for many people (myself
included) so he created a package. I used it to create a presentation about
Emacs (and introduction to it) to present in college. Presentatinos are made on
a elisp file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package demo-it
    :ensure t)
#+END_SRC

*** Pretty symbols

The package [[https://github.com/akatov/pretty-mode][pretty-mode]] provides default symbol replacements including in, not
in, and, or, and greek letters.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pretty-mode
    :ensure t
    :delight
    :config (global-pretty-mode))
#+END_SRC



** Text mode
:PROPERTIES:
:CUSTOM_ID: text-mode
:END:

Here are our definitions for the text mode files. Stuff like =txt=, =tex=, =org=
and =markdown= files.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; this is just some basic settings
  (add-hook 'text-mode-hook 'auto-fill-mode)
  (add-hook 'text-mode-hook
    '(lambda() (set-fill-column 80)))
#+END_SRC

*** Distraction free writing
:PROPERTIES:
:CUSTOM_ID: distraction-free-writing
:END:

A package that's similar to [[https://github.com/junegunn/goyo.vim][goyo.vim]].

#+BEGIN_SRC emacs-lisp
  (use-package writeroom-mode
    :config
    (add-hook 'writeroom-mode-hook
      (lambda ()
        (nlinum-mode -1))))
#+END_SRC

*** Markdown
:PROPERTIES:
:CUSTOM_ID: markdown
:END:

I need it.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :init (setq markdown-command "pandoc"))
#+END_SRC

*** LaTeX
:PROPERTIES:
:CUSTOM_ID: latex
:END:

Here we set up our LaTeX environment. I use AUCTeX to do must of my stuff, and
this LaTeX setup is heavily inspired by [[http://piotrkazmierczak.com/2010/emacs-as-the-ultimate-latex-editor/][this]] post.

#+BEGIN_SRC emacs-lisp
  ;; Activate flyspell, math-mode and reftex on every LaTeX buffer
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

  ;; Some settings
  (setq reftex-plug-into-AUCTeX t
        TeX-auto-save t
        TeX-parse-self t
        TeX-PDF-mode t
        TeX-save-query nil)

  (use-package auctex-latexmk
    :ensure t)
#+END_SRC

**** =latex-extra=
:PROPERTIES:
:CUSTOM_ID: latex-extra
:END:

This is a package that adds a ton of functionalities to LaTeX mode and some
bindings that resemble Org's.

#+BEGIN_SRC emacs-lisp
  (use-package latex-extra
    :config
    (add-hook 'LaTeX-mode-hook #'latex-extra-mode))
#+END_SRC

**** =magic-latex-buffer=
:PROPERTIES:
:CUSTOM_ID: magic-latex-buffer
:END:

This gives me some pretty symbols and previews also, but it can do much more (it
almost makes LaTeX a WYSIWYG).

 #+BEGIN_SRC emacs-lisp
   (use-package magic-latex-buffer
     :config
     ;(add-hook 'LaTeX-mode-hook 'magic-latex-buffer)
     (setq magic-latex-enable-pretty-symbols t
           magic-latex-enable-inline-image nil
           magic-latex-enable-suscript t
           magic-latex-enable-block-highlight nil
           magic-latex-enable-block-align t))
 #+END_SRC


** Coding
:PROPERTIES:
:CUSTOM_ID: coding
:END:

*** Infer indentation style
:PROPERTIES:
:CUSTOM_ID: infer-indentation-style
:END:

This is something I got from the [[https://www.emacswiki.org/emacs/NoTabs][EmacsWiki]]. The function is defined [[Custom functions][above]].

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
    (lambda () (my/infer-indentation-style)))
#+END_SRC

*** [[https://github.com/Malabarba/aggressive-indent-mode][=aggressive-indent-mode=]]
:PROPERTIES:
:CUSTOM_ID: aggressive-indent-mode
:END:

From their github:

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code always indented.
It reindents after every change, making it more reliable than
electric-indent-mode.
#+END_QUOTE

#+begin_src emacs-lisp :tangle yes
  (use-package aggressive-indent
    :ensure t
    :delight
    :config
    (aggressive-indent-global-mode 1)
    ; (add-to-list 'aggressive-indent-excluded-modes 'html-mode) ; this is an example
    )
#+END_SRC

*** What the tab key does
:PROPERTIES:
:CUSTOM_ID: what-the-tab-key-does
:END:

This part I got from [[http://ergoemacs.org/emacs/emacs_tabs_space_indentapassage_setup.html][this]] page on ergoemacs.

#+begin_src emacs-lisp
  ;; make tab key do indent first then completion.
  (setq-default tab-always-indent 'complete)
#+end_src

*** Tab width
:PROPERTIES:
:CUSTOM_ID: tab-width
:END:

That's all, just the tab width.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

*** Always indent newline
:PROPERTIES:
:CUSTOM_ID: always-indent-newline
:END:

Also pretty self explanatory.

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook
    (lambda () (local-set-key (kbd "RET") 'newline-and-indent)))
#+END_SRC

*** Expand region
:PROPERTIES:
:CUSTOM_ID: expand-region
:END:

Gradually expand selection.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :defer t
    :bind ("C-=" . er/expand-region))
#+END_SRC

*** Emacs Lisp
:PROPERTIES:
:CUSTOM_ID: emacs-lisp
:END:

**** Eldoc
:PROPERTIES:
:CUSTOM_ID: eldoc
:END:

Get some minibuffer hints when working with elisp.

 #+BEGIN_SRC emacs-lisp
   (use-package eldoc
     :ensure t
     :delight
     :commands eldoc-mode
     :defer t
     :init
     (progn
     (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
     (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)))
 #+END_SRC

*** Snippets
:PROPERTIES:
:CUSTOM_ID: snippets
:END:

This is just a snippet package.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :delight
    :init (yas-global-mode)
    :config
    (yas-global-mode 1))

  (use-package yasnippet-snippets
    :ensure t
    :delight)
#+END_SRC

*** Auto completion
:PROPERTIES:
:CUSTOM_ID: auto-completion
:END:

I use [[http://company-mode.github.io/][=company-mode=]] for auto-completion.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :delight
    :config

    (use-package company-auctex
      :ensure t)

    (use-package company-ghc
      :ensure t)

    (use-package company-ghci
      :ensure t)

    (use-package company-irony
      :ensure t)

    (use-package company-irony-c-headers
      :ensure t)

    (use-package company-c-headers
      :ensure t)

    ;; set default `company-backends'
    (add-to-list 'company-backends '(company-irony
                                     company-auctex
                                     company-ghc
                                     company-ghci
                                     company-irony-c-headers
                                     company-c-headers))

    (setq company-idle-delay 0.5
          company-echo-delay 0.5
          company-dabbrev-downcase nil
          company-minimum-prefix-length 2
          company-selection-wrap-around t
          company-global-modes '(not eshell-mode)
          company-transformers '(company-sort-by-occurrence
                                 company-sort-by-backend-importance))

    (define-key evil-insert-state-map (kbd "C-SPC") 'company-complete)
    (define-key company-active-map (kbd "<tab>") 'company-complete)
    (define-key company-active-map (kbd "C-n") 'company-select-next)
    (define-key company-active-map (kbd "C-p") 'company-select-previous)

    (global-company-mode))
#+END_SRC

*** Syntax checking
:PROPERTIES:
:CUSTOM_ID: syntax-checking
:END:

I use flycheck for syntax checking on various languages. I have some
specific linters for some of them like python.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
    :ensure t
    :delight
    :config
    (setq flycheck-mode-line '(:eval (replace-regexp-in-string
                                      "FlyC" "ùìï"
                                      (flycheck-mode-line-status-text))))
    (add-hook 'after-init-hook #'global-flycheck-mode))

  (use-package flycheck-haskell
    :ensure t
    :delight)

  (use-package flycheck-irony
    :ensure t
    :delight)

  (use-package flycheck-checkbashisms
    :ensure t
    :delight
    :config
    (flycheck-checkbashisms-setup))
#+END_SRC

*** Tag navigation
:PROPERTIES:
:CUSTOM_ID: tag-navigation
:END:

I use GNU Global as my tagging system; this package aims to (and successfully
does) give you and Emacs interface to GNU Global.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ggtags
    :ensure t
    :delight
    :config
    (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
    (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
    (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
    (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
    (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
    (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags))
#+END_SRC

*** Show column number
:PROPERTIES:
:CUSTOM_ID: show-column-number
:END:

I find it useful.

#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC

*** Show matching pairs
:PROPERTIES:
:CUSTOM_ID: show-matching-pairs
:END:

Just a simple mode to show matching pairs of parenthesis, curly braces, etc...
It has a little bit of a delay that I removed, and I also changed slightly the
color/face of it.

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
  (set-face-foreground 'show-paren-match "#def")
  (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
#+END_SRC

*** Magit
:PROPERTIES:
:CUSTOM_ID: magit
:END:

This is also one of the selling points of Emacs for me.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :config
    (global-set-key (kbd "M-G") 'magit))

  (use-package magithub
    :ensure t
    :after magit
    :config
    (magithub-feature-autoinject t)
    (setq magithub-clone-default-directory "~/github"))
#+END_SRC

Refer to [[http://pages.sachachua.com/.emacs.d/Sacha.html#magit][Sasha magit]] later.

*** Projects
:PROPERTIES:
:CUSTOM_ID: projects
:END:

I use projectile to manage projects just because it makes it all so much easier.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :delight
    :config
    (progn
      (setq projectile-keymap-prefix (kbd "C-c p"))
      (setq projectile-completion-system 'default)
      (setq projectile-enable-caching t)
      (setq projectile-indexing-method 'alien)
      (add-to-list 'projectile-globally-ignored-files "node-modules"))
    (projectile-global-mode))
#+END_SRC

*** Modes
:PROPERTIES:
:CUSTOM_ID: org-modules
:END:

Some major modes configuration and packages.

**** Haskell
:PROPERTIES:
:CUSTOM_ID: haskell
:END:

 #+BEGIN_SRC emacs-lisp
   (defun disable-haskell-indentation-mode ()
     (haskell-indentation-mode -1))

   (use-package haskell-mode
     :ensure t
     :delight
     :config
     (add-hook 'haskell-mode-hook 'haskell-doc-mode)

     (add-hook 'haskell-mode-hook (lambda () (haskell-indentation-mode 0)))
     (remove-hook 'haskell-mode-hook 'turn-on-haskell-indentation)

     (eval-after-load "haskell-mode"
       '(define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile))
     (eval-after-load 'haskell-mode
       '(define-key haskell-mode-map [f8] 'haskell-navigate-imports))
     (let ((my/cabal-path (expand-file-name "~/.cabal/bin"))
       (setenv "PATH" (concat my/cabal-path path-separator (getenv "PATH")))
       (add-to-list 'exec-path my/cabal-path))
     (custom-set-variables '(haskell-tags-on-save t))))

   (use-package haskell-snippets
     :ensure t
     :delight)
 #+END_SRC

**** Vimscript
:PROPERTIES:
:CUSTOM_ID: vimscript
:END:

 #+BEGIN_SRC emacs-lisp
   (use-package vimrc-mode
     :ensure t
     :delight)
 #+END_SRC

**** Python
:PROPERTIES:
:CUSTOM_ID: python
:END:

This is a package to have a IDE-like development environment on Pyhton.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; use the correct debugging command for python
  (setq gud-pdb-command-name "python -m pdb")

  (use-package elpy
    :ensure t
    :delight
    :config
    (elpy-enable)
    (setq python-shell-interpreter "python"
          python-shell-interpreter-args "-i"))
 #+END_SRC

**** C/C++
:PROPERTIES:
:CUSTOM_ID: c-c++
:END:

[[https://github.com/Sarcasm/irony-mode][=irony-mode=]] is minor mode to help developmente in C/C++ and ObjC.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'objc-mode-hook 'irony-mode)

    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

*** Surround text

#+BEGIN_QUOTE
Corral is a lightweight package that lets you quickly wrap parentheses and other
delimiters around text, intuitively surrounding what you want it to using just
two commands.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package corral
    :ensure t
    :config
    (defhydra hydra-corral (:columns 4)
      "corral"
      ("(" corral-parentheses-backward "back")
      (")" corral-parentheses-forward "forward")
      ("[" corral-brackets-backward "back")
      ("]" corral-brackets-forward "forward")
      ("{" corral-braces-backward "back")
      ("}" corral-braces-forward "forward")
      ("\"" corral-double-quotes-backward "back")
      ("\'" corral-double-quotes-forward "forward")
      ("q" nil "quit")
      ("." hydra-repeat "repeat"))

    (global-set-key (kbd "C-c c") 'hydra-corral/body)

    (global-set-key (kbd "M-9") 'corral-parentheses-backward)
    (global-set-key (kbd "M-0") 'corral-parentheses-forward)
    (global-set-key (kbd "M-[") 'corral-brackets-backward)
    (global-set-key (kbd "M-]") 'corral-brackets-forward)
    (global-set-key (kbd "M-{") 'corral-braces-backward)
    (global-set-key (kbd "M-}") 'corral-braces-forward)
    (global-set-key (kbd "M-\"") 'corral-double-quotes-backward)
    (global-set-key (kbd "M-\'") 'corral-double-quotes-forward))
#+END_SRC


* TODO =hl-todo=

This package highlights all of the /TODO's/ in the file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (require 'hl-todo)
  (set-face-attribute 'hl-todo nil :weight 'bold :foreground "black" :background "yellow")
  (global-hl-todo-mode)
#+END_SRC

* TODO IRC
:PROPERTIES:
:CUSTOM_ID: irc
:END:

* TODO Mail
:PROPERTIES:
:CUSTOM_ID: mail
:END:
