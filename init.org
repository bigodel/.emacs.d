#+TITLE: heartb1t's Emacs
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:t

* TODO review the bindings location

* TODO configure pdf-tools and look for dpi var for docview
* TODO look into emms


* Introduction
:PROPERTIES:
:CUSTOM_ID: intro
:END:

#+BEGIN_QUOTE
No Emacs configuration is original, everything is a copy of a bunch of other
peoples' configs.

    -- Me
#+END_QUOTE

** About
:PROPERTIES:
:CUSTOM_ID: about
:END:

This configuration is almost a full copy of Bailey Ling's config, availabe in
[[https://github.com/bling/dotemacs][this link]]. I highly recommend you check out his config first, even though mine
do not differ much. I also recommend you to check out [[https://github.com/purcell/emacs.d][Steve Purcell's]] config. If
none of those two are your cup of tea, there is a compilation of [[https://github.com/caisah/emacs.dz][awesome emacs
configs]] to help you get started (or restarted) on you journey to create the
perfect editor.

My aim here was to use his KISS (Keep It Simple Stupid) approach to Emacs
configuration and merge it with a literate programming approach. Usually
literate programming Emacs' configuration files are one huge Org file that
tangles all of the code blocks into a single =init.el=. This can get pretty
messy pretty quick (in my opinion), so I prefer to keep a bunch of files
separate, each with their own context. For example, since =helm= is [[https://tuhdo.github.io/helm-intro.html][A Package in
a league of its own]] it makes sense to have a =config/init-helm.el=.

You might not want to simply copy and paste this into your configuration, I
recommend you get used to the defaults of Emacs (I'm using [[https://github.com/emacs-evil/evil][evil-mode]]) and
Emacs Lisp, so you can understand everything written in here. For a introduction
(a very comprehensive one) in elisp, refer to [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in
Emacs Lisp]] from the GNU Project website, or you could use the built in info by
typing =C-h i= and selecting "Emacs Lisp Intro". Also, as Sasha Chua
recommended, you could paste small portions of =elisp= code in the =*scratch*=
buffer and use the command =M-x eval buffer= to see what that code might do
without making the change permanent.

If you're viewing the Org file, you can open source code blocks (those are the
ones in =#+BEGIN_SRC=) in a separate buffer by moving your point inside them and
typing =C-c ' (org-edit-special)=. This opens another buffer in
=emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the changes. If you
want to explore how functions work, use =M-x edebug-defun= to set up debugging
for that function, and then call it. You can learn more about =edebug= in the
[[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp manual]].

** Tools
:PROPERTIES:
:CUSTOM_ID: tools
:END:

The heart of this setup lies in 3 snippets of elisp/common lisp code.

*** =require-package=
:PROPERTIES:
:CUSTOM_ID: require-pkg
:END:

The first is a wrapper on the =require= Emacs function (you can learn more about
it with =C-h f RET require=). It checks if the package is installed and if not
install it, and then uses =require= to load its libraries. This was actually
[[https://github.com/purcell/emacs.d][Purcell's]] idea, and copied from its config.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  If NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (if (or (package-installed-p package min-version)
            (require package nil 'noerror))
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          (if (boundp 'package-selected-packages)
              ;; Record this as a package the user installed explicitly
              (package-install package nil)
            (package-install package))
        (progn
          (package-refresh-contents)
          (require-package package min-version t)))))
#+END_SRC

*** =after=
:PROPERTIES:
:CUSTOM_ID: after
:END:

=with-eval-after-load= is a function that lets you defer execution of code until
after a feature has been loaded. It is very useful to only load some packages
when they're (we don't want Python related packages to be loaded when we are
hacking elisp, right?), and because of that it is extensively used in this
setup. So of course there is a macro to make it simpler. It can also run code if
a package has been installed by using "pkgname-autoloads" or only if multiple
packages have been loaded. This also avoids loading config for packages that
haven't been loaded yet, resulting in void variables of function definitions.
This was take from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]] (along with some other things).

#+BEGIN_SRC emacs-lisp :tangle no
  ;; examples
  (after 'magit
    ;; execute after magit has been loaded
    )
  (after "magit-autoloads"
    ;; execute if magit is installed/available
    )
  (after [evil magit]
    ;; execute after evil and magit have been loaded
    )

  ;; macro definiton
  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+END_SRC

*** Bootstrap
:PROPERTIES:
:CUSTOM_ID: bootstrap
:END:

The last and simplest of all is just a common lisp loop at the end of =init.el=
(the main configuration file) to recursively load all of the files ending in
=.el= inside the =config/= directory. That ensures that all of our configuration
scattered in a lot of files is loaded. If you want to add additional
configuration for a new language, simply create =new-language.el= in
=config/langs= and it will automatically be loaded. Files are loaded in reverse
order so that any functions defined will be available in child nodes.

#+BEGIN_SRC emacs-lisp :tangle no
  (cl-loop for file in
           (reverse (directory-files-recursively config-directory "\\.el$"))
           do (load file))
#+END_SRC

*** Bindings
:PROPERTIES:
:CUSTOM_ID: bindings
:END:

Other important part (but not necessarily the heart) of the setup are the
bindings, which are mostly kept on the =config/init-bindings.el=. Some
packages and modes have too much bindings, so they have their own specific
bindings file under the =config/bindings= directory. Because of this, things
like =use-package= aren't particularly useful here because it doesn't add much
value over =require-package= and =after=.

Keybindings are the single most differentiating factor between configs. By
defining them in one place, if you want to use/fork this config, you can simply
change the bindings to your liking and still use all the other pre-configured
packages as is. If you're not an =evil= user, delete =config-evil.el= and you
will get a pure Emacs experience.

*** Lazy major modes
:PROPERTIES:
:CUSTOM_ID: lazy-major-modes
:END:

Another important part is that by combining =after=, =require-package= and
=auto-mode-alist=, packages are only installed when needed. So python packages
are only installed if a python file is opened (and so for any other language).
If you never open a python file, none of the python specific packages will ever
be installed.


* Main file

This is the main configuration file, the one that ties all of the others
together.

I start by enabling automatic debugging on errors and then requiring some common
lisp libraries and then setting up a lexical variable to store the start-up time
for Emacs, and then display it in the minibuffer when Emacs loads.

The next code block sets the garbage collector threshold and the =core= and
=config= directories, where our configuration files are going to be. Right after
all of the bars are disabled if they're enabled.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (setq debug-on-error nil)

  (eval-when-compile (require 'cl))

  (lexical-let ((emacs-start-time (current-time)))
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((elapsed (float-time
                                (time-subtract (current-time) emacs-start-time))))
                  (message "[ Emacs initialized in %.3fs ]" elapsed)))))

  (let ((gc-cons-threshold (* 256 1024 1024))
        (file-name-handler-alist nil)
        (config-directory (concat user-emacs-directory "config/")))

    (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    (when (fboundp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
#+END_SRC

These serve the purpose of choosing what package to use for different parts of
my Emacs setup, like completion engine, which could either be =helm=, =ido= or
=ivy=.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (defvar dotemacs-cache-directory (concat user-emacs-directory ".cache/")
    "The storage location for various persistent files.")

  (when (and (not (file-directory-p dotemacs-cache-directory))
             (y-or-n-p
              (format "Directory `%s' does not exist! Create it?"
                      dotemacs-cache-directory)))
    (make-directory dotemacs-cache-directory t))

  (defvar dotemacs-globally-ignored-directories
    '("elpa" ".cache" "target" "dist" "node_modules" ".git" ".hg" ".svn" ".idea")
    "A set of default directories to ignore for anything that
    involves searching.")
#+END_SRC

Here is where we set the default repositories from where Emacs should fetch
packages from.

This is where we load all of our configuration files stored in
=~/.emacs.d/config= and any custom configuration in the file
=~/.emacs.d/custom.el=. The first to be loaded is the core part, followed by the
=custom.el= file. Then there is a common lisp loop to recursively load all of
the elisp files in =~/.emacs.d/config=.

#+BEGIN_SRC emacs-lisp :tangle init.el
    (setq package-archives '(("melpa" . "http://melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("gnu" . "http://elpa.gnu.org/packages/")))
    (setq package-enable-at-startup nil)
    (package-initialize)
#+END_SRC

Note that if the variable =user-emacs-directory= is changed to, let's say,
=~/.myemacs=, this configuration file will look for elisp files in =~/.myemacs/=
and =~/.myemacsc/config/= instead of the above mentioned paths with
=~/.emacs.d/=.

#+BEGIN_SRC emacs-lisp :tangle init.el
  (load (concat config-directory "init-boot"))

  (setq custom-file (concat user-emacs-directory "custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file))

  (cl-loop for file in (reverse (directory-files-recursively
                                 config-directory "\\.el$"))
           do (condition-case ex
                  (load (file-name-sans-extension file))
                ('error (with-current-buffer "*scratch*"
                          (insert (format "[INIT ERROR]\n%s\n%s\n\n" file ex)))))
           (load (file-name-sans-extension file))))

  (provide 'init.el) ;;; init.el ends here
#+END_SRC


* Config
:PROPERTIES:
:CUSTOM_ID: cfg
:END:

This is the section where configuration actually takes place.

** Boot
:PROPERTIES:
:CUSTOM_ID: cfg-boot
:END:

We also load the common lisp libraries here.

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (eval-when-compile (require 'cl))
#+END_SRC

Load any manually installed packages on the =elisp/= directory.

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (let ((base (concat user-emacs-directory "elisp/")))
    (when (and (not (file-exists-p base))
               (y-or-n-p
                (format "Directory `%s' does not exist! Create it?"
                        base)))
      (make-directory base t))
    (add-to-list 'load-path base)
    (dolist (dir (directory-files base t "^[^.]"))
      (when (file-directory-p dir)
        (add-to-list 'load-path dir))))
#+END_SRC

This handy macro creates a new buffer with the name =*Load Times*= and shows a
moderately detailed information about the load time of TARGET. It is used here
to show the load times of packages loaded with =require= or =load=.

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (defmacro /boot/measure-load (target &rest body)
    (declare (indent defun))
    `(let ((elapsed)
           (start (current-time)))
       (prog1
           ,@body
         (with-current-buffer (get-buffer-create "*Load Times*")
           (when (= 0 (buffer-size))
             (insert (format "| %-60s | %-23s | elapsed  |\n" "feature" "timestamp"))
             (insert "|--------------------------------------------------------------+-------------------------+----------|\n"))
           (goto-char (point-max))
           (setq elapsed (float-time (time-subtract (current-time) start)))
           (insert (format "| %-60s | %s | %f |\n"
                           ,target
                           (format-time-string "%Y-%m-%d %H:%M:%S.%3N" (current-time))
                           elapsed))))))

  (defadvice load (around dotemacs activate)
    (/boot/measure-load file ad-do-it))

  (defadvice require (around dotemacs activate)
    (if (memq feature features)
        ad-do-it
      (/boot/measure-load feature ad-do-it)))

  (defmacro bind (&rest commands)
    "Convenience macro which creates a lambda interactive command."
    `(lambda (arg)
       (interactive "P")
       ,@commands))
#+END_SRC

Here are the macros mentioned on the [[#intro][introduction]] section.

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (defun require-package (package &optional min-version no-refresh)
    "Install given PACKAGE, optionally requiring MIN-VERSION.
  If NO-REFRESH is non-nil, the available package lists will not be
  re-downloaded in order to locate PACKAGE."
    (if (or (package-installed-p package min-version)
            (require package nil 'noerror))
        t
      (if (or (assoc package package-archive-contents) no-refresh)
          (if (boundp 'package-selected-packages)
              ;; Record this as a package the user installed explicitly
              (package-install package nil)
            (package-install package))
        (progn
          (package-refresh-contents)
          (require-package package min-version t)))))

  (defun maybe-require-package (package &optional min-version no-refresh)
    "Try to install PACKAGE, and return non-nil if successful.
  In the event of failure, return nil and print a warning message.
  Optionally require MIN-VERSION.  If NO-REFRESH is non-nil, the
  available package lists will not be re-downloaded in order to
  locate PACKAGE."
    (condition-case err
        (require-package package min-version no-refresh)
      (error
       (message "Couldn't install optional package `%s': %S" package err)
       nil)))
  (unless (fboundp 'with-eval-after-load)
    (defmacro with-eval-after-load (file &rest body)
      (declare (indent 1))
      `(eval-after-load ,file (lambda () ,@body))))

  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+END_SRC

This macro is to lazily install a major mode like described in [[#lazy-major-modes][Lazy major modes]].

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (defmacro /boot/lazy-major-mode (pattern mode)
    "Defines a new major-mode matched by PATTERN, installs MODE if
  necessary, and activates it."
    `(add-to-list 'auto-mode-alist
                  '(,pattern . (lambda ()
                                 (require-package ,mode)
                                 (,mode)))))

  (defmacro /boot/delayed-init (&rest body)
    "Runs BODY after idle for a predetermined amount of time."
    `(run-with-idle-timer
      0.5
      nil
      (lambda () ,@body)))

  (provide 'init-boot)
#+END_SRC

This function is to create a ask to create a directory if trying to access a
non-existing directory.

#+BEGIN_SRC emacs-lisp :tangle config/init-boot.el
  (defun /boot/create-non-existent-directory (&optional dir)
    "When trying to access non-existing directories, ask to create them.
  If DIR is provided, ask to create DIR."
    (let ((parent-directory (or (bound-and-true-p dir)
                                (file-name-directory buffer-file-name))))
      (when (and (not (file-exists-p parent-directory))
                 (y-or-n-p (format "Directory `%s' does not exist! Create it?"
                                   parent-directory)))
        (make-directory parent-directory t))))

  (add-to-list 'find-file-not-found-functions
               #'/boot/create-non-existent-directory)
#+END_SRC

** Core
:PROPERTIES:
:CUSTOM_ID: cfg-core
:END:

Here we place some core configurations, without depending on any package. Just
some default Emacs config.

First we create a variable for the coding system, which is UTF-8 by default.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (defvar dotemacs-core/default-coding-system 'utf-8
    "The default coding system to use.")
#+END_SRC

This setting sets the default location for the Emacs socket to be in and then
initializes the server if it is not already running.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (defvar dotemacs-core/server-directory
    (format "%s/emacs%d/" (or (getenv "TMPDIR") "/tmp") (user-uid))
    "The storage location for the socket file used to connect to the daemon.")
  (setq server-socket-dir dotemacs-core/server-directory)
  (setq server-auth-dir (concat dotemacs-core/server-directory "server"))
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC

Some personal information.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq user-full-name "JoÃ£o Pedro de Amorim Paula")
  (setq user-mail-address "jpedrodeamorim@gmail.com")
#+END_SRC

=saveplace= is a minor mode that automatically saves place in each file. This
means when you visit a file, point goes to the last place where it was when you
previously visited the same file. =savehist-mode= save the minibuffer history in
the file defined by =savehist-file=. And =recentf= displays recently visited
files (excluding some temporary files we don't want to revisit).

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  ;; move cursor to the last position upon open
  (require 'saveplace)
  (setq save-place-file (concat dotemacs-cache-directory "places"))
  (save-place-mode t)

  ;; savehist
  (setq savehist-file (concat dotemacs-cache-directory "savehist")
        savehist-additional-variables '(search ring regexp-search-ring)
        savehist-autosave-interval 60
        history-length 1000)
  (savehist-mode t)

  ;; recent files
  (require 'recentf)
  (setq recentf-save-file (concat dotemacs-cache-directory "recentf"))
  (setq recentf-max-saved-items 1000)
  (setq recentf-max-menu-items 500)
  (setq recentf-auto-cleanup 300)
  (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")
  (add-to-list 'recentf-exclude ".*elpa.*autoloads\.el$")
  (recentf-mode t)
  (run-with-idle-timer 600 t #'recentf-save-list)
#+END_SRC

These configurations are regarding garbage collection on Emacs. I mostly took it
from [[http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][this]] post.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  ;; gc
  (defun /core/minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun /core/minibuffer-exit-hook ()
    (setq gc-cons-threshold (* 64 1024 1024)))
  (add-hook 'minibuffer-setup-hook #'/core/minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'/core/minibuffer-exit-hook)
#+END_SRC

By default Emacs has =whitespace-mode=. It is used to show whitespace. For more
information, visit [[https://www.emacswiki.org/emacs/WhiteSpace#toc1][this]] page. The configuration I got mostly from [[http://ergoemacs.org/emacs/whitespace-mode.html][here]].

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (require 'whitespace)

  ;; (setq whitespace-display-mappings
  ;;       '((space-mark 32 [183])
  ;;         (newline-mark 10 [182 10])
  ;;         (tab-mark 9 [9655 9] [92 9])))

  (setq whitespace-style '(face trailing tabs lines-tail))

  ;; (set-face-attribute 'whitespace-space nil
  ;;                     :background nil
  ;;                     :foreground "black")

  (set-face-attribute 'whitespace-trailing nil
                      :background "gray15")

  (add-hook 'after-save-hook 'whitespace-cleanup)

  (global-whitespace-mode t)
#+END_SRC

Another neat feature Emacs has by default it Dynamic Abbreviations (=dabbrev=).
It After you type a word once, if you type that word again, you can type it
partially and =M-/= to complete it. If you type a prefix that has many
candidates, =M-/= cycles the candidates. =hippie-expand= is basically
=dabbrev-extend= on steroids. It adds a bunch of completion engines to the mix.
It has an info page =C-h F hippie-expand= in case you want to know more, and the
[[https://www.emacswiki.org/emacs/HippieExpand][EmacsWiki page]] has a bunch of configurations for different modes.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))

  (global-set-key (kbd "M-/") #'hippie-expand)

  (setq save-abbrevs 'silently)
#+END_SRC

Auto-fill mode wraps the line whenever it reaches the value of =fill-column=. So
here we activate it and also set the =fill-column= value. The =fill-column= is
also used by =fill-paragraph=. I also created a little function to auto fill
comments on programming modes, but not auto fill the code itself.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq-default fill-column 80)

  (defun /core/comment-auto-fill ()
     (setq-local comment-auto-fill-only-comments t)
     (turn-on-auto-fill))

  (add-hook 'prog-mode-hook #'/core/comment-auto-fill)

  (add-hook 'text-mode-hook #'turn-on-auto-fill)
#+END_SRC

Here we configure the behavior of some default Emacs functions. If you'd like to
take a look at what they do you could =C-h f= (or =C-h a=) and type the name of
the function (the comment right before the config) or search on the web, but I
recommend you look the default documentation about it on Emacs first. It is also
in this portion that I have added a hook to reload tangle and compile Emacs
every time it loads.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (add-hook 'after-save-hook #'/util/tangle-init)

  ;; pcomplete
  (setq pcomplete-ignore-case t)

  ;; imenu
  (setq-default imenu-auto-rescan t)

  ;; narrowing
  (put 'narrow-to-region 'disabled nil)

  ;; dired
  (require 'dired-x)

  ;; url
  (setq url-configuration-directory (concat dotemacs-cache-directory "url/"))

  ;; tramp
  (setq tramp-persistency-file-name (concat dotemacs-cache-directory "tramp"))
  (setq tramp-default-method "ssh")
  (setq remote-file-name-inhibit-cache nil)
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
  ;; (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))

  ;; comint
  (after 'comint
    (defun /core/toggle-comint-scroll-to-bottom-on-output ()
      (interactive)
      (if comint-scroll-to-bottom-on-output
          (setq comint-scroll-to-bottom-on-output nil)
        (setq comint-scroll-to-bottom-on-output t))))

  ;; compile
  (setq compilation-always-kill t)
  (setq compilation-ask-about-save nil)
  (add-hook 'compilation-filter-hook
            (lambda ()
              (when (eq major-mode 'compilation-mode)
                (require 'ansi-color)
                (let ((inhibit-read-only t))
                  (ansi-color-apply-on-region (point-min) (point-max))))))

  ;; bookmarks
  (setq bookmark-default-file (concat dotemacs-cache-directory "bookmarks"))
  (setq bookmark-save-flag 1) ;; save after every change

  ;; fringe
  (when (display-graphic-p)
    (fringe-mode '(8 . 8)))

  ;; ediff
  (setq ediff-split-window-function 'split-window-horizontally) ;; side-by-side diffs
  (setq ediff-window-setup-function 'ediff-setup-windows-plain) ;; no extra frames

  ;; re-builder
  (setq reb-re-syntax 'string) ;; fix backslash madness

  ;; clean up old buffers periodically
  (midnight-mode)
  (midnight-delay-set 'midnight-delay 0)

  ;; ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode)

  ;; move auto-save to the cache
  (let ((dir (expand-file-name (concat dotemacs-cache-directory "auto-save/"))))
    (setq auto-save-list-file-prefix (concat dir "saves-"))
    (setq auto-save-file-name-transforms `((".*" ,(concat dir "save-") t))))

  ;; multiple-backups
  (setq backup-directory-alist `((".*" . ,(expand-file-name (concat dotemacs-cache-directory "backups/")))))
  (setq backup-by-copying t)
  (setq version-control t)
  (setq kept-old-versions 2)
  (setq kept-new-versions 20)
  (setq delete-old-versions t)

  ;; better scrolling
  (setq scroll-conservatively 9999
        scroll-preserve-screen-position t
        scroll-margin 1)

  ;; better buffer names for duplicates
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"
        uniquify-ignore-buffers-re "^\\*" ; leave special buffers alone
        uniquify-after-kill-buffer-p t)

  (require 'paren)
  (set-face-background 'show-paren-match (face-foreground 'default))
  (set-face-foreground 'show-paren-match (face-background 'default))
  (set-face-attribute 'show-paren-match nil :weight 'extra-bold)
  (show-paren-mode 1)

  (setq show-paren-delay 0)

  (defun /core/do-not-kill-scratch-buffer ()
    (if (member (buffer-name (current-buffer))
                '("*scratch*" "*Messages*" "*Require Times*"))
        (progn (bury-buffer) nil)
      t))
  (add-hook 'kill-buffer-query-functions #'/core/do-not-kill-scratch-buffer)
#+END_SRC

Change the "yes or no" prompt to "y-or-n", set the coding system based on the
custom variable we defined above and set some variables value.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (defalias 'yes-or-no-p 'y-or-n-p)

  (let ((coding 'utf-8))
    (setq locale-coding-system coding)
    (set-selection-coding-system coding)
    (set-default-coding-systems coding)
    (prefer-coding-system coding)
    (setq-default buffer-file-coding-system coding))

  (setq sentence-end-double-space nil)
  (setq ring-bell-function 'ignore)
  (setq mark-ring-max 64)
  (setq global-mark-ring-max 128)
  (setq select-enable-clipboard t)
  (setq save-interprogram-paste-before-kill nil)
  (setq create-lockfiles nil)
  (setq echo-keystrokes 0.01)
  (setq eval-expression-print-level nil)
#+END_SRC

These are some configurations regarding indentation.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq-default indent-tabs-mode nil) ;; spaces instead of tabs
  (setq-default tab-width 4)

  (defun /core/infer-indentation-style ()
    "If our source file uses tabs, we use tabs, if spaces spaces,
  and if neither, we use the current indent-tabs-mode"
    (let ((space-count (how-many "^  " (point-min) (point-max)))
          (tab-count (how-many "^\t" (point-min) (point-max))))
      (if (> space-count tab-count) (setq indent-tabs-mode nil))
      (if (> tab-count space-count) (setq indent-tabs-mode t))))

  (add-hook 'prog-mode-hook #'/core/infer-indentation-style)
#+END_SRC

Do not show the initial default splash screen and do not show any message on
start-up.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-echo-area-message t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)
#+END_SRC

Some modes that I like to have by default.

#+BEGIN_SRC emacs-lisp :tangle config/init-core.el
  (setq truncate-lines nil)
  (setq-default truncate-lines nil)
  (xterm-mouse-mode t)
  (which-function-mode t)
  (blink-cursor-mode -1)
  (global-auto-revert-mode t)
  (electric-indent-mode t)
  (transient-mark-mode t)
  (delete-selection-mode t)
  (random t) ;; seed

  (defun /core/find-file-hook ()
    (when (string-match "\\.min\\." (buffer-file-name))
      (fundamental-mode)))
  (add-hook 'find-file-hook #'/core/find-file-hook)

  (provide 'init-core)
#+END_SRC

** Languages

Here is where I store configuration for specific languages.

*** C/C++

Configuration regarding C/C++ and some packages.

#+BEGIN_SRC emacs-lisp :tangle config/langs/lang-c-cpp.el
  (setq-default c-basic-offset (symbol-value 'tab-width))
#+END_SRC

*** Java
*** Haskell

I work a lot with Haskell, here is configuration regarding it.

First we have to install the =haskell-mode=, since it doesn't come by default in
Emacs. Then we set the =haskell-mode= to be the major mode for the =.ghci= file.

#+BEGIN_SRC emacs-lisp :tangle config/langs/lang-haskell.el
  (require-package 'haskell-mode)

  (/boot/lazy-major-mode "\\.ghci\\'" 'haskell-mode)
#+END_SRC

[[https://github.com/commercialhaskell/intero][=intero=]] is a /"complete interactive development program for Haskell"/. It

#+BEGIN_SRC emacs-lisp :tangle config/langs/lang-haskell.el
  ;; (when (maybe-require-package 'intero)
  ;;   (after 'haskell-mode
  ;;     (intero-global-mode)
  ;;     (add-hook 'haskell-mode-hook #'subword-mode)
  ;;     (add-hook 'haskell-mode-hook #'eldoc-mode))
  ;;   (after 'haskell-cabal
  ;;     (add-hook 'haskell-cabal-mode #'subword-mode)
  ;;     (define-key haskell-cabal-mode-map (kbd "C-c C-l") 'intero-restart))
  ;;   (after [intero flycheck]
  ;;     (flycheck-add-next-checker 'intero
  ;;                                '(warning . haskell-hlint))))
#+END_SRC

** Util
:PROPERTIES:
:CUSTOM_ID: cfg-util
:END:

Some useful functions. They are pretty much self documented, so there ain't much
more I could say about it.

#+BEGIN_SRC emacs-lisp :tangle config/init-util.el
  (defun /util/window-killer ()
    "Closes the window, and deletes the buffer if it's the last window open."
    (interactive)
    (if (> buffer-display-count 1)
        (if (= (length (window-list)) 1)
            (kill-buffer)
          (delete-window))
      (kill-buffer-and-window)))

  (defun /util/minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (defun /util/set-transparency (alpha)
    "Sets the transparency of the current frame."
    (interactive "nAlpha: ")
    (set-frame-parameter nil 'alpha alpha))

  (defun /util/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

  (defun /util/eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (preceding-sexp))))
      (backward-kill-sexp)
      (insert (format "%s" value))))

  (defun /util/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))

  (defun /util/delete-current-buffer-file ()
    "Kill the current buffer and deletes the file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (if (vc-backend filename)
            (vc-delete-file filename)
          (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
            (delete-file filename)
            (message "Deleted file %s" filename)
            (kill-buffer))))))

  (defun /util/goto-scratch-buffer ()
    "Create a new scratch buffer."
    (interactive)
    (switch-to-buffer (get-buffer-create "*scratch*")))

  (defun /util/insert-last-kbd-macro ()
    (interactive)
    (name-last-kbd-macro 'my-last-macro)
    (insert-kbd-macro 'my-last-macro))

  (defun /util/set-buffer-to-unix-format ()
    "Converts the current buffer to UNIX file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix nil))

  (defun /util/set-buffer-to-dos-format ()
    "Converts the current buffer to DOS file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun /util/find-file-as-root (file)
    "Edits a file as root."
    (interactive "f")
    (find-file-other-window (concat "/sudo:root@localhost:" file)))

  (defun /util/tangle-init ()
    (interactive)
    "If the current buffer is init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (provide 'init-util)
#+END_SRC

** Evil
:PROPERTIES:
:CUSTOM_ID: cfg-evil
:END:

Probably my most used packages, by far.

Here we set some variables of things that should not start as =evil-mode= (kinda
contradictory isn't it?) because =evil= is awesome but ain't perfect yet.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (defvar dotemacs-evil/emacs-state-hooks
    '(org-log-buffer-setup-hook
      org-capture-mode-hook)
    "List of hooks to automatically start up in Evil Emacs state.")

  (defvar dotemacs-evil/emacs-state-major-modes
    '(calculator-mode
      makey-key-mode)
    "List of major modes that should default to Emacs state.")

  (defvar dotemacs-evil/emacs-state-minor-modes
    '(git-commit-mode
      magit-blame-mode)
    "List of minor modes that when active should switch to Emacs state.")

  (defvar dotemacs-evil/emacs-insert-mode nil
    "If non-nil, insert mode will act as Emacs state.")
#+END_SRC

Some variable configuration for =evil= to feel more like (n)vim.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (setq evil-search-module 'isearch-regexp)
  (setq evil-magic 'very-magic)
  (setq evil-shift-width (symbol-value 'tab-width))
  (setq evil-regexp-search t)
  (setq evil-search-wrap t)
  (setq evil-want-C-i-jump t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-fine-undo nil)
  (setq evil-want-integration nil)
  (setq evil-want-abbrev-on-insert-exit nil)
  (setq evil-want-abbrev-expand-on-insert-exit nil)
  ;; move evil tag to beginning of modeline
  (setq evil-mode-line-format '(before . mode-line-front-space))
#+END_SRC

I usually know in what =evil= state I'm in by the cursor color because of the
configuration.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (setq evil-emacs-state-cursor '("red" box))
  (setq evil-motion-state-cursor '("white" box))
  (setq evil-normal-state-cursor '("magenta" box))
  (setq evil-visual-state-cursor '("orange" box))
  (setq evil-insert-state-cursor '("red" bar))
  (setq evil-replace-state-cursor '("red" hbar))
  (setq evil-operator-state-cursor '("red" hollow))
#+END_SRC

Here is where I actually start =evil= after setting some more variables and
hooks. Also in this code snippet is where all of the lists of default states for
some modes set above are actually set with a common lisp loop. I've also added,
in the end of this code block, and advice to indent every time we use =o= or
=O=.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (add-hook 'evil-jumps-post-jump-hook #'recenter)

  (require-package 'evil)
  (require 'evil)
  (evil-mode)

  (cl-loop for mode in dotemacs-evil/emacs-state-minor-modes
           do (let ((hook (concat (symbol-name mode) "-hook")))
                (add-hook (intern hook) (lambda ()
                                          (if ,mode
                                              (evil-emacs-state)
                                            (evil-normal-state))))))

  (cl-loop for hook in dotemacs-evil/emacs-state-hooks
           do (add-hook hook #'evil-emacs-state))

  (cl-loop for mode in dotemacs-evil/emacs-state-major-modes
           do (evil-set-initial-state mode 'emacs))

  (after 'evil-common
    (evil-put-property 'evil-state-properties 'normal   :tag " NORMAL ")
    (evil-put-property 'evil-state-properties 'insert   :tag " INSERT ")
    (evil-put-property 'evil-state-properties 'visual   :tag " VISUAL ")
    (evil-put-property 'evil-state-properties 'motion   :tag " MOTION ")
    (evil-put-property 'evil-state-properties 'emacs    :tag " EMACS ")
    (evil-put-property 'evil-state-properties 'replace  :tag " REPLACE ")
    (evil-put-property 'evil-state-properties 'operator :tag " OPERATOR "))

  (when dotemacs-evil/emacs-insert-mode
    (defalias 'evil-insert-state 'evil-emacs-state)
    (define-key evil-emacs-state-map (kbd "<escape>") 'evil-normal-state))

  (unless (display-graphic-p)
    (evil-esc-mode 1))
#+END_SRC

Here is the configuration for the comment package. And some more additional
packages to help integrate =evil= into the most modes possible.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (after 'magit
    (require-package 'evil-magit)
    (require 'evil-magit)
    (evil-magit-init))

  (after 'org
    (require-package 'evil-org)
    (require 'evil-org)
    (add-hook 'org-mode-hook #'evil-org-mode)
    (add-hook 'evil-org-mode-hook
              (lambda ()
                (evil-org-set-key-theme))))

  (after 'vimish-fold
    (require-package 'evil-vimish-fold)
    (require 'evil-vimish-fold)
    (evil-vimish-fold-mode t))

  (require-package 'evil-matchit)
  (defun evilmi-customize-keybinding ()
    (evil-define-key 'normal evil-matchit-mode-map
      "%" 'evilmi-jump-items))
  (global-evil-matchit-mode t)

  (require-package 'evil-numbers)
  (require 'evil-numbers)
#+END_SRC

I also use [[https://github.com/emacs-evil/evil-collection][=evil-collection=]], a set of keybindings for =evil-mode=.

#+BEGIN_SRC emacs-lisp :tangle config/init-evil.el
  (after 'evil
    (require-package 'evil-collection)
    (setq evil-collection-setup-minibuffer t)
    (setq evil-collection-company-use-tng t)
    (evil-collection-init))

  (defadvice evil-ex-search-next (after dotemacs activate)
    (recenter))

  (defadvice evil-ex-search-previous (after dotemacs activate)
    (recenter))

  (provide 'init-evil)
#+END_SRC

** Helm
   :PROPERTIES:
   :CUSTOM_ID: cfg-helm
   :END:

Helm is a /Emacs incremental completion and selection narrowing framework/
https://emacs-helm.github.io/helm.

#+BEGIN_QUOTE
People often think helm is just something like [[https://www.emacswiki.org/emacs/InteractivelyDoThings][=ido=]] but displaying
completion in a vertical layout instead of an horizontal one, it is not,
helm is much more powerful than that.

  - Helm is able to complete multiple lists dispatched in different sources
    against a pattern.

  - Helm allows executing an unlimited number of actions on candidates.

  - Helm allows marking candidates to execute chosen action against this set of
    candidates.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle config/init-helm.el
  (require-package 'helm)
  (require 'helm)

  (setq helm-bookmark-show-location t)
  (setq helm-buffer-max-length 40)
  (setq helm-split-window-inside-p t)
  (setq helm-mode-fuzzy-match t)
  (setq helm-ff-file-name-history-use-recentf t)
  (setq helm-ff-skip-boring-files t)
  (setq helm-follow-mode-persistent t)

  (after 'helm-source
    (defun /helm/make-source (f &rest args)
      (let ((source-type (cadr args))
            (props (cddr args)))
        (unless (child-of-class-p source-type 'helm-source-async)
          (plist-put props :fuzzy-match t))
        (apply f args)))
    (advice-add 'helm-make-source :around '/helm/make-source))
#+END_SRC

Helm also has a lot of other packages to integrate it to other packages and
parts of Emacs that the default package doesn't cover. Here are some of those.

#+BEGIN_SRC emacs-lisp :tangle config/init-helm.el
  (after 'helm
    (require-package 'helm-descbinds)

    (require-package 'helm-flx)
    (helm-flx-mode t)

    (require-package 'helm-dash)
    (setq helm-dash-browser-func 'eww)

    (require-package 'helm-ag)
    (setq helm-ag-fuzzy-match t)
    (setq helm-ag-use-agignore t)
    (setq helm-ag-ignore-patterns dotemacs-globally-ignored-directories)
    (after 'helm-ag
      (cond ((executable-find "ag")
             t)
            ((executable-find "pt")
             (setq helm-ag-base-command "pt -e --nogroup --nocolor"))
            ((executable-find "ack")
             (setq helm-ag-base-command "ack --nogroup --nocolor"))))

    (setq helm-swoop-pre-input-function #'ignore)
    (setq helm-swoop-use-line-number-face t)
    (setq helm-swoop-split-with-multiple-windows t)
    (setq helm-swoop-speed-or-color t)
    (setq helm-swoop-use-fuzzy-match t)
    (require-package 'helm-swoop)

    (after "projectile-autoloads"
      (require-package 'helm-projectile))

    (require-package 'helm-tramp)

    ;; take between 10-30% of screen space
    (setq helm-autoresize-min-height 10)
    (setq helm-autoresize-max-height 30)
    (helm-autoresize-mode t))
#+END_SRC

Start =helm= with the default =find-file= and =M-x= functions to be
=helm='s alternatives. And also start =helm= on idle time
(=delayed-init=).

#+BEGIN_SRC emacs-lisp :tangle config/init-helm.el
  (/boot/delayed-init
   (progn
     (global-set-key [remap execute-extended-command] #'helm-M-x)
     (global-set-key [remap find-file] #'helm-find-files)
     (helm-mode t)))

  (provide 'init-helm)
#+END_SRC

** Bindings
:PROPERTIES:
:CUSTOM_ID: cfg-bindings
:END:

This is one of the most crucial points of the setup, as explained in the
[[#bindings][bindings]] section.

=which-key= is a very helpful tool to help you remember bindings. If you type a
prefix key and stay idle for more than 0.2s without pressing another key,
=which-key= will show you every possible binding with its related function
starting with the prefix you pressed.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  (require-package 'which-key)
  (require 'which-key)
  (setq which-key-idle-delay 0.2)
  (setq which-key-min-display-lines 3)
  (setq which-key-max-description-length 20)
  (setq which-key-max-display-columns 6)
  (which-key-mode)
#+END_SRC

These macros are to help me remap keys.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  (defmacro /bindings/define-prefix-keys (keymap prefix &rest body)
    (declare (indent defun))
    `(progn
       ,@(cl-loop for binding in body
                  collect
                  `(let ((seq ,(car binding))
                         (func ,(cadr binding))
                         (desc ,(caddr binding)))
                     (define-key ,keymap (kbd seq) func)
                     (when desc
                       (which-key-add-key-based-replacements
                         (if ,prefix
                             (concat ,prefix " " seq)
                           seq)
                         desc))))))

  (defmacro /bindings/define-keys (keymap &rest body)
    (declare (indent defun))
    `(/bindings/define-prefix-keys ,keymap nil ,@body))

  (defmacro /bindings/define-key (keymap sequence binding &optional description)
    (declare (indent defun))
    `(/bindings/define-prefix-keys ,keymap nil
       (,sequence ,binding ,description)))
#+END_SRC

With this, pressing =ESC= actually leaves the minibuffer. Also, like
in Vim's "minibuffer", pressing =C-w= deletes a word back. This is now
commented because I have =evil-collection-setup-minibuffer= activated
by default, which makes the minibuffer behave like a normal emacs
buffer with =evil= activated.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  ;; escape minibuffer
  ;; (define-key minibuffer-local-map [escape]
  ;;   '/util/minibuffer-keyboard-quit)
  ;; (define-key minibuffer-local-ns-map [escape]
  ;;   '/util/minibuffer-keyboard-quit)
  ;; (define-key minibuffer-local-completion-map [escape]
  ;;   '/util/minibuffer-keyboard-quit)
  ;; (define-key minibuffer-local-must-match-map [escape]
  ;;   '/util/minibuffer-keyboard-quit)
  ;; (define-key minibuffer-local-isearch-map [escape]
  ;;   '/util/minibuffer-keyboard-quit)

  ;; (define-key minibuffer-local-map (kbd "C-w") 'backward-kill-word)
#+END_SRC

First I map =C-S-n= to create a new below where the point is, and
=C-S-o= to create one above. The rest is just more configuration
regarding a bunch of packages and modes.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  (global-set-key (kbd "C-x C-/") #'/util/find-file-as-root)

  (global-set-key (kbd "M-;") #'comment-line)

  (after "expand-region-autoloads"
    (global-set-key (kbd "C-=") #'er/expand-region))

  ;; mouse scrolling in terminal
  (unless (display-graphic-p)
    (global-set-key [mouse-4] (bind (scroll-down 1)))
    (global-set-key [mouse-5] (bind (scroll-up 1))))

  (after 'compile
    (define-key compilation-mode-map (kbd "j") 'compilation-next-error)
    (define-key compilation-mode-map (kbd "k") 'compilation-previous-error))
#+END_SRC

I like using =helm= to pretty much anything I can, so I set most of the common
variables as =helm= commands. I also find it useful to remap the
=helm-command-prefix= to =C-c h=, because it is easy to mistype =C-x C-c= with
the default prefix. I also map =M-!= and =C-!= to use =eshell= instead of the
default.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  (after 'helm
    (require 'helm-config)
    (global-set-key (kbd "C-c h") #'helm-command-prefix)
    (global-unset-key (kbd "C-x c"))
    (global-set-key (kbd "C-h a") #'helm-apropos)
    (global-set-key (kbd "C-x b") #'helm-buffers-list)
    (global-set-key (kbd "C-x C-b") #'helm-mini)
    (global-set-key (kbd "C-x C-f") #'helm-find-files)
    (global-set-key (kbd "C-x r b") #'helm-bookmarks)
    (global-set-key (kbd "M-x") #'helm-M-x)
    (global-set-key (kbd "M-y") #'helm-show-kill-ring)
    (global-set-key (kbd "M-:") #'helm-eval-expression-with-eldoc)
    (define-key helm-map (kbd "<tab>") #'helm-execute-persistent-action)
    (define-key helm-map (kbd "C-z") #'helm-select-action)

    (after "helm-ag-autoloads"
      (global-set-key (kbd "C-c h g") #'helm-do-ag))

    (after "helm-swoop-autoloads"
      (global-set-key (kbd "C-c h S") #'helm-swoop))

    (after "helm-tramp-autoloads"
      (global-set-key (kbd "C-x t") #'helm-tramp)))

  (global-set-key (kbd "M-!") #'eshell-command)
  (global-set-key (kbd "C-!") #'/eshell/new-window)
#+END_SRC

These bindings are mostly regarding third party packages, that's why most of
them are wrapped in a =after=. This first one is worth explaining; when using
=company=, if you are on the completion pop-up and hit the tab key, it will
first look for a snippet from =yasnippet= and if there is none it will use the
current selection as the Completion. For example, if you type =def= on any
=elisp= mode, it will have tons of completion candidates, but it is also a
snippet for =defun=, so if you hit tab, it will actually trigger the =defun=
snippet.

#+BEGIN_SRC emacs-lisp :tangle config/init-bindings.el
  (after 'company
    (after "yasnippet-autoloads"
      (define-key company-active-map (kbd "<tab>")
        (bind (when (null (yas-expand))
                (company-complete-selection))))))

  (define-key company-active-map (kbd "RET") 'company-complete-selection)

  (after 'magit
    (global-set-key (kbd "C-x g") #'magit-status)
    (global-set-key (kbd "C-x M-g") #'magit-dispatch-popup)

    (after 'magit-todos
      (define-key magit-todos-section-map (kbd "j") 'evil-next-line)
      (define-key magit-todos-section-map (kbd "k") 'evil-previous-line)))

    (after 'projectile
      (define-key projectile-mode-map (kbd "C-c p") #'projectile-command-map)
      (global-set-key (kbd "C-S-p") #'projectile-switch-project))

  (after 'evil
    (define-key evil-normal-state-map (kbd "!") #'/eshell/new-window)
    (define-key evil-visual-state-map (kbd "!") #'/eshell/new-window)
    (define-key evil-motion-state-map (kbd "!") #'/eshell/new-window))

  (/bindings/define-keys (current-global-map)
    ("C-c c" #'org-capture)
    ("C-c a" #'org-agenda)
    ("C-c l" #'org-store-link)
    ("C-c s" #'/util/goto-scratch-buffer)
    ("C-c e" #'/util/eval-and-replace)
    ("C-c t" #'/eshell/new-window))

  (/bindings/define-keys (current-global-map)
    ("C-x c" #'calculator)
    ("C-x C" #'calendar)
    ("C-x C-k" #'kill-this-buffer)
    ("C-x p" #'proced))

  (global-set-key (kbd "<M-f7>") (bind (profiler-start 'cpu+mem)))
  (global-set-key (kbd "<M-f6>") (bind (profiler-report) (profiler-stop)))

  (provide 'init-bindings)
#+END_SRC

Some packages have specific bindings and/or too much bindings to be on the
=config/init-bindings.el= file, so they have their own.

*** Evil bindings
    :PROPERTIES:
    :CUSTOM_ID: cfg-bindings-evil
    :END:

Since it is my most used package it makes total sense that is has it's own file.

#+BEGIN_SRC emacs-lisp :tangle config/bindings/bind-evil.el
  (after 'evil
    (/bindings/define-keys evil-normal-state-map ("g d" #'dumb-jump-go))

    (require-package 'key-chord)
    (key-chord-mode 1)
    (key-chord-define evil-insert-state-map "jk" 'evil-normal-state)
    (key-chord-define evil-insert-state-map "kj" 'evil-normal-state)

    (after "evil-numbers-autoloads"
      (/bindings/define-key evil-normal-state-map "C-a" #'evil-numbers/inc-at-pt)
      (/bindings/define-key evil-normal-state-map "C-S-a" #'evil-numbers/dec-at-pt))

    (after "company-autoloads"
      (define-key evil-insert-state-map (kbd "TAB")
        #'company-indent-or-complete-common))

    (/bindings/define-keys evil-normal-state-map
      ("SPC" ":noh")
      ("C-b" #'evil-scroll-up)
      ("C-f" #'evil-scroll-down))

    (after 'evil-evilified-state
      (/bindings/define-keys evil-evilified-state-map
        ("C-w h" #'evil-window-left)
        ("C-w j" #'evil-window-down)
        ("C-w h" #'evil-window-up)
        ("C-w l" #'evil-window-right)))

    (/bindings/define-keys evil-normal-state-map
      ("C-w h" #'evil-window-left)
      ("C-w j" #'evil-window-down)
      ("C-w k" #'evil-window-up)
      ("C-w l" #'evil-window-right))

    (/bindings/define-key evil-normal-state-map "Y" "y$"))

  (provide 'init-bindings-evil)
#+END_SRC

** Eyecandy
:PROPERTIES:
:CUSTOM_ID: cfg-eyecandy
:END:

Some eyecandy is good.

Color theme config and font config.

#+BEGIN_SRC emacs-lisp :tangle config/init-eyecandy.el
  (require-package 'solarized-theme)
  (setq solarized-scale-org-headlines nil)
  (setq x-underline-at-descent-line t)
  (require 'solarized-theme)

  (require-package 'monokai-theme)

  (require-package 'gruvbox-theme)

  (load-theme 'manoj-dark t)

  ;; change fringe background and foreground color
  (set-face-attribute 'fringe nil
                      :background (face-background 'default)
                      :foreground (face-foreground 'default))

  ;; make comments grey (manoj-dark)
  (set-face-foreground 'font-lock-comment-face "dimgray")
  (set-face-foreground 'font-lock-comment-delimiter-face "dimgray")

  ;; disable the bigger scale on bold function fonts (manoj-dark)
  (set-face-attribute 'font-lock-function-name-face nil :height 1.0)

  ;; change line number color (manoj-dark)
  (after 'linum
    (set-face-attribute 'linum nil :foreground "gold"))

  ;; change mode-line's font size and foreground and background
  (set-face-attribute 'mode-line nil
                      :height 1.0
                      :background (face-foreground 'default)
                      :foreground (face-background 'default))
  (set-face-attribute 'mode-line-buffer-id nil
                      :height 1.0
                      :background (face-foreground 'default)
                      :foreground (face-background 'default))

  ;; default font
  (add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-14"))

  ;; increase, decrease and adjust font size
  (global-set-key (kbd "C-+") #'text-scale-increase)
  (global-set-key (kbd "C--") #'text-scale-decrease)
  (global-set-key (kbd "C-0") #'text-scale-adjust)
#+END_SRC

Also there is some mode to display stuff in the modeline that are very useful.

#+BEGIN_SRC emacs-lisp :tangle config/init-eyecandy.el
  (line-number-mode t)
  (column-number-mode t)
  (size-indication-mode t)
#+END_SRC

Here is the configuration regarding the folding method.

#+BEGIN_SRC emacs-lisp :tangle config/init-eyecandy.el
  (require-package 'vimish-fold)
  (require 'vimish-fold)
  (vimish-fold-global-mode t)
#+END_SRC

The =diminish= package hides minor modes from the modeline.

#+BEGIN_SRC emacs-lisp :tangle config/init-eyecandy.el
  ;; (require-package 'delight)

  ;; (delight '((auto-fill-mode nil t)
  ;;            (auto-revert-mode nil autorevert)
  ;;            (abbrev-mode nil abbrev)
  ;;            (whitespace-mode nil whitespace)
  ;;            (helm-mode nil helm-mode)
  ;;            (flyspell-mode nil flyspell)
  ;;            (projectile-mode nil projectile)
  ;;            (yas-minor-mode nil yasnippet)
  ;;            (undo-tree-mode nil undo-tree)
  ;;            (which-key-mode nil which-key)
  ;;            (company-mode nil company)
  ;;            (aggressive-indent-mode nil aggressive-indent)
  ;;            (evil-org-mode nil evil-org)
  ;;            (evil-vimish-fold-mode nil evil-vimish-fold)
  ;;            (eldoc-mode nil eldoc)
  ;;            (highlight-symbol-mode nil hightlight-symbol)
  ;;            ))

  ;; (delight 'server-buffer-clients nil 'server)
  ;; (delight 'auto-fill-function nil t)

  (require-package 'diminish)
  (require 'diminish)

  (diminish 'visual-line-mode)
  (diminish 'auto-fill-function)
  (after 'whitespace
    (diminish 'global-whitespace-mode)
    (diminish 'whitespace-mode))
  (after 'org-indent (diminish 'org-indent-mode))
  (after 'outline (diminish 'outline-minor-mode))
  (after 'aggressive-indent (diminish 'aggressive-indent-mode))
  (after 'autorevert (diminish 'auto-revert-mode))
  (after 'abbrev (diminish 'abbrev-mode))
  (after 'subword (diminish 'subword-mode))
  (after 'color-identifiers-mode (diminish 'color-identifiers-mode))
  (after 'company (diminish 'company-mode))
  (after 'counsel (diminish 'counsel-mode))
  (after 'eldoc (diminish 'eldoc-mode))
  (after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
  (after 'flycheck (diminish 'flycheck-mode))
  (after 'flyspell (diminish 'flyspell-mode))
  (after 'git-gutter+ (diminish 'git-gutter+-mode))
  (after 'helm-mode (diminish 'helm-mode))
  (after 'hideshow (diminish 'hs-minor-mode))
  (after 'highlight-symbol (diminish 'highlight-symbol-mode))
  (after 'indent-guide (diminish 'indent-guide-mode))
  (after 'ivy (diminish 'ivy-mode))
  (after 'page-break-lines (diminish 'page-break-lines-mode))
  (after 'projectile (diminish 'projectile-mode))
  (after 'undo-tree (diminish 'undo-tree-mode))
  (after 'which-key (diminish 'which-key-mode))
  (after 'yasnippet (diminish 'yas-minor-mode))
  (after 'evil-org (diminish 'evil-org-mode))
  (after 'evil-vimish-fold (diminish 'evil-vimish-fold-mode))
  (after 'proof-site (diminish 'proof-active-buffer-fake-minor-mode))
  (after "intero-autoloads" (diminish 'intero-mode))
#+END_SRC

=prettify-symbols= replaces ASCII characters with a unicode representation of
them. For example, on Lisp dialects, the word "/lambda/" is replaced by the
actual greek letter /Î»/. It is also possible to add your own mappings like so:

/Ps.: This is not going to be tangled/

#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
            (push '(">=" . ?â¥) prettify-symbols-alist)
            (push '("<=" . 2264) prettify-symbols-alist)))

;; you can use either the ?char or the char code; for example, ?â¥ is the same as
;; 2265
#+END_SRC

These are some eye candy packages. If you're interested in any of them just look
them up on your favorite search engine.

#+BEGIN_SRC emacs-lisp :tangle config/init-eyecandy.el
  (when (fboundp 'global-prettify-symbols-mode)
    (global-prettify-symbols-mode))

  (/boot/delayed-init
   (require-package 'color-identifiers-mode)
   (global-color-identifiers-mode)
   (diminish 'color-identifiers-mode))

  (require-package 'highlight-symbol)
  (setq highlight-symbol-idle-delay 0.3)
  (add-hook 'prog-mode-hook #'highlight-symbol-mode)

  (require-package 'highlight-numbers)
  (add-hook 'prog-mode-hook #'highlight-numbers-mode)

  (require-package 'highlight-quoted)
  (add-hook 'prog-mode-hook #'highlight-quoted-mode)

  (require-package 'page-break-lines)
  (global-page-break-lines-mode)

  (provide 'init-eyecandy)
#+END_SRC

** Misc
:PROPERTIES:
:CUSTOM_ID: cfg-misc
:END:

This section is some miscellaneous stuff.

A package to make dired more beautiful.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (after 'dired
    (require-package 'dired-k)
    (setq dired-k-style 'git)
    (setq dired-k-human-readable t)
    (add-hook 'dired-initial-position-hook #'dired-k))
#+END_SRC

A tree to visualize modifications on the file and go back to previous states.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (require-package 'undo-tree)
  (setq undo-tree-auto-save-history t)
  (setq undo-tree-enable-undo-in-region nil)
  (setq undo-tree-history-directory-alist
        `(("." . ,(concat dotemacs-cache-directory "undo/"))))
  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)
  (global-undo-tree-mode)
#+END_SRC

Jump to definition on Emacs. It doesn't need TAGS file or anything like this, it
only uses =ag= or =grep= or =ripgrep= or =rg=.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (require-package 'dumb-jump)
  (after [evil dumb-jump]
         (defadvice dumb-jump-go (before dotemacs activate)
           (evil-set-jump)))
#+END_SRC

=ag= is a very fast code searching tool.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (when (executable-find "ag")
    (require-package 'ag)
    (require 'ag)
    (setq ag-highlight-search t)
    (setq ag-ignore-list dotemacs-globally-ignored-directories)
    (add-hook 'ag-mode-hook (lambda () (toggle-truncate-lines t))))
#+END_SRC

=expand-region= let's you keep expanding the selection. =aggressive-indent= is a
package to indent, you want it or not, your code.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (require-package 'expand-region)

  (require-package 'aggressive-indent)
  (require 'aggressive-indent)
  (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
  (add-hook 'lisp-mode-hook #'aggressive-indent-mode)
#+END_SRC

=popwin= is used to better manage pop-up windows. =restart-emacs= makes it
easier to restart your config and load new code snippets.

#+BEGIN_SRC emacs-lisp :tangle config/init-misc.el
  (require-package 'popwin)
  (require 'popwin)
  (push '(compilation-mode :noselect t) popwin:special-display-config)
  (popwin-mode)

  (provide 'init-misc)
#+END_SRC

** =eshell=
:PROPERTIES:
   :CUSTOM_ID: cfg-eshell
   :END:

=eshell= is the Emacs shell, a shell written in Emacs Lisp. It is great to
execute commands while on Emacs. I like it better than =ansi-term= or =term=,
but I don't use it as my main shell (and it is not intended to, even though some
people do).

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (defvar dotemacs-eshell/prompt-git-info
    (executable-find "git")
    "Full path for the `git' executable.")

  (defvar dotemacs-eshell/visual-commands
    '("ssh" "top" "tail" "less")
    "Command that present their output in a visual fashion.")

  (defadvice eshell/exit (before dotemacs activate)
    "After exiting `eshell', remove its window."
    (delete-window))
#+END_SRC

Some variable configuration.

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (setq eshell-directory-name (concat dotemacs-cache-directory "eshell"))
  (setq eshell-buffer-maximum-lines 20000)
  (setq eshell-scroll-to-bottom-on-input 'this)
  (setq eshell-buffer-shorthand t)
  (setq eshell-aliases-file (concat user-emacs-directory "alias"))
  (setq eshell-glob-case-insensitive nil)
  (setq eshell-error-if-no-glob t)
  (setq eshell-history-size (* 10 1024))
  (setq eshell-hist-ignoredups t)
  (setq eshell-cmpl-ignore-case t)
#+END_SRC

This is the prompt function for =eshell= (usually called =$PS1= on =bash= or
=zsh=). I'm not currently using this, because it made =eshell= a little slow and
I didn't like it, but I decided to leave it here if anyone wants to try it out.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq eshell-prompt-function
        (lambda ()
          "The function to generate `eshell's prompt."
          (concat
           (propertize (abbreviate-file-name (eshell/pwd)) 'face 'eshell-prompt)
           (when (and dotemacs-eshell/prompt-git-info
                      (fboundp #'vc-git-branches))
             (let ((branch (car (vc-git-branches))))
               (when branch
                 (concat
                  (propertize " [" 'face 'font-lock-keyword-face)
                  (propertize branch 'face 'font-lock-function-name-face)
                  (let* ((status (shell-command-to-string "git status --porcelain"))
                         (parts (split-string status "\n" t " "))
                         (states (mapcar #'string-to-char parts))
                         (added (count-if (lambda (char) (= char ?A)) states))
                         (modified (count-if (lambda (char) (= char ?M)) states))
                         (deleted (count-if (lambda (char) (= char ?D)) states)))
                    (when (> (+ added modified deleted) 0)
                      (propertize
                       (format " +%d ~%d -%d" added modified deleted)
                       'face 'font-lock-comment-face)))
                  (propertize "]" 'face 'font-lock-keyword-face)))))
           (propertize " $ " 'face 'font-lock-constant-face))))
#+END_SRC

If you have fortune installed, show a fortune every time =eshell= is opened.

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (when (executable-find "fortune")
    (defadvice eshell (before dotemacs activate)
      (setq eshell-banner-message
            (concat (shell-command-to-string "fortune") "\n"))
      "Display a little `fortune' at `eshell's startup."))
#+END_SRC

Functions defined as =eshell/name-of-function= are functions executed on
=eshell= whenever you type =name-of-function= and press Enter.

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (defun eshell/ff (&rest args)
    "Opens a file in emacs."
    (when (not (null args))
      (mapc #'find-file (mapcar #'expand-file-name
                                (eshell-flatten-list (reverse args))))))

  (defun eshell/h ()
    "Quickly run a previous command."
    (insert (completing-read
             "Run previous command: "
             (delete-dups (ring-elements eshell-history-ring))
             nil
             t))
    (eshell-send-input))

  (defun eshell/tramp (&rest args)
    "Use tramp as a eshell command."
    (insert (apply #'format "cd /ssh:%s:\\~/" args))
    (eshell-send-input))
#+END_SRC

After =em-term= is loaded, add the new visual commands to the list of visual
commands. Also, when on =eshell=, =gst= opens up =magit=.

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (after 'em-term
    (dolist (cmd dotemacs-eshell/visual-commands)
      (add-to-list 'eshell-visual-commands cmd)))

  (after "magit-autoloads"
    (defun eshell/gst (&rest args)
      (magit-status (pop args) nil)
      (eshell/echo)))
#+END_SRC

This function splits the current window in half, opening a new =eshell= instance
on the lower half of the window. It also =cd='s into the current working
directory and renames the =eshell= buffer to =*eshell: directory*= and sends an
=ls= as output as soon as it starts.

#+BEGIN_SRC emacs-lisp :tangle config/init-eshell.el
  (defun /eshell/new-window ()
    "Opens up a new shell in the directory associated with the
    current buffer's file. The eshell is renamed to match that
    directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 2))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))

      (insert (concat "ls"))
      (eshell-send-input)))

  (provide 'init-eshell)
#+END_SRC

** Version Control System
   :PROPERTIES:
   :CUSTOM_ID: cfg-vcs
   :END:

Configuration regarding the VCS. It is based on =magit=, one of the best Emacs
packages and a reason a lot of people stick to it (of course, if they use git).

#+BEGIN_SRC emacs-lisp :tangle config/init-vcs.el
  (setq vc-make-backup-files t)

  (when (executable-find "git")
    (add-hook 'git-commit-mode-hook
              (lambda ()
                (interactive)
                (next-line)))

    (require-package 'magit)
    (require 'magit)

    (setq magit-section-show-child-couno t)
    (setq magit-diff-arguments '("--histogram"))
    (setq magit-ediff-dwim-show-on-hunks t)
    (setq magit-display-buffer-function #'magit-display-buffer-traditional)

    (add-hook 'magit-mode-hook #'hl-line-mode)

    (require-package 'magit-todos)
    (add-hook 'prog-mode-hook #'hl-todo-mode)
    (setq magit-todos-fontify-org nil)
    (when (executable-find "rg")
      (setq magit-todos-scanner 'magit-todos--scan-with-rg))
    (magit-todos-mode t))

  (/boot/lazy-major-mode "\\.gitignore$" 'gitignore-mode)
  (/boot/lazy-major-mode "\\.gitattributes$" 'gitattributes-mode)

  (after [evil diff-mode]
    (evil-define-key 'normal diff-mode diff-mode-map
      "j" #'diff-hunk-next
      "k" #'diff-hunk-prev))
  (after [evil vc-annotate]
    (evil-define-key 'normal vc-annotate-mode-map
      (kbd "M-p") #'vc-annotate-prev-revision
      (kbd "M-n") #'vc-annotate-next-revision
      "l" #'vc-annotate-show-log-revision-at-line))

  (provide 'init-vcs)
#+END_SRC

** Flycheck
   :PROPERTIES:
   :CUSTOM_ID: cfg-flycheck
   :END:

This is a syntax checking package for Emacs. It is a pretty simple
configuration. I added some bindings to help out with =evil-mode= and I like to
have it always on.

#+BEGIN_SRC emacs-lisp :tangle config/init-flycheck.el
  (require-package 'flycheck)
  (require 'flycheck)

  (setq flycheck-standard-error-navigation t)

  (after 'web-mode
         (flycheck-add-mode 'javascript-eslint 'web-mode))

  (add-hook 'after-init-hook #'global-flycheck-mode)

  (after [evil flycheck]
    (evil-define-key 'normal flycheck-error-list-mode-map
      "j" #'flycheck-error-list-next-error
      "k" #'flycheck-error-list-previous-error))

  (defun /flycheck/advice/next-error-find-buffer (orig-func &rest args)
    (let* ((special-buffers
            (cl-loop for buffer in (mapcar #'window-buffer (window-list))
                     when (with-current-buffer buffer
                            (and
                             (eq (get major-mode 'mode-class) 'special)
                             (boundp 'next-error-function)))
                     collect buffer))
           (first-special-buffer (car special-buffers)))
      (if first-special-buffer
          first-special-buffer
        (apply orig-func args))))

  (advice-add #'next-error-find-buffer :around #'/flycheck/advice/next-error-find-buffer)

  (provide 'init-flycheck)
#+END_SRC

** Flyspell

Flyspell highlights incorrect words as soon as they are completed or as soon as
the [[https://www.emacswiki.org/emacs/TextCursor][TextCursor]] hits a new word.

#+BEGIN_SRC emacs-lisp :tangle config/init-flyspell.el
  (add-hook 'prog-mode-hook #'flyspell-prog-mode)
  (add-hook 'text-mode-hook #'turn-on-flyspell)
#+END_SRC

** Auxiliary modes
   :PROPERTIES:
   :CUSTOM_ID: cfg-aux-modes
   :END:

Some major modes that are not installed by default.

#+BEGIN_SRC emacs-lisp :tangle config/init-auxiliary-modes.el
  (/boot/lazy-major-mode "\\.\\(md\\|markdown\\)$" 'markdown-mode)
  (/boot/lazy-major-mode "\\.toml$" 'toml-mode)
  (/boot/lazy-major-mode "\\.yaml$" 'yaml-mode)
  (/boot/lazy-major-mode "\\.json$" 'json-mode)
  (/boot/lazy-major-mode "\\.vim$" 'vimrc-mode)
  (/boot/lazy-major-mode "\\.lua$" 'lua-mode)
  (/boot/lazy-major-mode "\\.csv$" 'csv-mode)
  (/boot/lazy-major-mode "\\.?cron\\(tab\\)?\\'" 'crontab-mode)

  (provide 'init-auxiliary-modes)
#+END_SRC

** Company
   :PROPERTIES:
   :CUSTOM_ID: cfg-company
   :END:

This is the auto-completion engine I use. Configuration is pretty straight
forward. There are some other packages for each language. Those packages are
configured and installed on the language's or mode's config section.

#+BEGIN_SRC emacs-lisp :tangle config/init-company.el
  (require-package 'company)
  (require 'company)

  (setq company-idle-delay 0.5)
  (setq company-minimum-prefix-length 1)
  (setq company-tooltip-limit 20)
  (setq company-auto-complete 'company-explicit-action-p)

  (setq company-dabbrev-downcase nil)
  (setq company-dabbrev-ignore-case t)

  (setq company-dabbrev-code-ignore-case t)
  (setq company-dabbrev-code-everywhere t)

  (setq company-global-modes
        '(not
          eshell-mode comint-mode text-mode erc-mode))

  (global-company-mode)

  (after 'yasnippet
    (setq company-backends
          (mapcar
           (lambda (backend)
             (if (and (listp backend) (member 'company-yasnippet backend))
                 backend
               (append (if (consp backend) backend (list backend))
                       '(:with company-yasnippet))))
           company-backends)))

  (provide 'init-company)
#+END_SRC

** Yasnippet
   :PROPERTIES:
   :CUSTOM_ID: cfg-yasnippet
   :END:

And this is my snippet package. The configuration is even smaller.

#+BEGIN_SRC emacs-lisp :tangle config/init-yasnippet.el
  (require-package 'yasnippet)
  (require 'yasnippet)

  (after 'yasnippet
    (require-package 'yasnippet-snippets)
    (require-package 'yasnippet-classic-snippets))

  (require 'yasnippet)

  (setq yas-fallback-behavior 'return-nil)
  (setq yas-also-auto-indent-first-line t)
  (setq yas-prompt-functions '(yas-ido-prompt yas-completing-prompt))

  (yas-global-mode t)

  (yas-load-directory (concat user-emacs-directory "snippets"))

  (provide 'init-yasnippet)
#+END_SRC

** Projectile
   :PROPERTIES:
   :CUSTOM_ID: cfg-projectile
   :END:

This package is amazing at dealing with projects.

#+BEGIN_SRC emacs-lisp :tangle config/init-projectile.el
  (require-package 'projectile)
  (require 'projectile)

  (setq projectile-cache-file
        (concat dotemacs-cache-directory "projectile.cache"))
  (setq projectile-known-projects-file
        (concat dotemacs-cache-directory "projectile-bookmarks.eld"))
  (setq projectile-indexing-method 'alien)
  (setq projectile-enable-caching t)
  (setq projectile-completion-system 'helm)
#+END_SRC

[[#cfg-helm][Helm]] also integrates very well with Projectile, making it one of the most useful
combos of my configuration.

#+BEGIN_SRC emacs-lisp :tangle config/init-projectile.el
  (after 'helm-projectile
    (add-to-list 'helm-projectile-sources-list
                 'helm-source-projectile-recentf-list))

  (projectile-mode)
#+END_SRC

Here we add the globally ignored directories that we store in a variable to the
projectile ignored directories. Also, pass as an argument to the searchers the
ignored directories.

#+BEGIN_SRC emacs-lisp :tangle config/init-projectile.el
  (dolist (dir dotemacs-globally-ignored-directories)
    (add-to-list 'projectile-globally-ignored-directories dir))

  (cond
   ((executable-find "ag")
    (setq projectile-generic-command
          (concat "ag -0 -l --nocolor"
                  (mapconcat #'identity
                             (cons "" projectile-globally-ignored-directories)
                             " --ignore-dir="))))
   ((executable-find "ack")
    (setq projectile-generic-command
          (concat "ack -f --print0"
                  (mapconcat #'identity
                             (cons "" projectile-globally-ignored-directories)
                             " --ignore-dir=")))))

  (provide 'init-projectile)
#+END_SRC

** Org

I use =org-mode= a lot (my whole configuration file is written in =org-mode=).
It is capable of storing notes, taking care of TODOs, being your agenda, store
contacts (all of that with sync capacities), evaluating LaTeX code, automatic
blog posting, etc...

Here we set some default variables. And create the default org directory if it
is not already created.

#+BEGIN_SRC emacs-lisp :tangle config/init-org.el
  (after 'org
    (setq org-directory (concat (getenv "HOME") "/docs/org"))

    (unless (file-directory-p org-directory)
      (unless (/boot/create-non-existent-directory org-directory)
      (let ((default-org (concat (getenv "HOME") "/Documents/Org")))
        (if (y-or-n-p
         (format "Failed to create `%s', use the default directory for org files [%s]?"
                 org-directory default-org))
            (progn (make-directory (concat (getenv "HOME") "/Documents/Org") t)
                   (setq org-directory (concat (getenv "HOME") "/Documents")))
          (error (concat "Couldn't load the configuration for org-mode. Try again or remove the file init-org.el from the config folder"))))))

    (defvar dotemacs-org/journal-file (concat org-directory "/journal.org")
      "The path to the file where you want to make journal entries.")

    (defvar dotemacs-org/inbox-file (concat org-directory "/inbox.org")
      "The path to the file where to capture notes.")

    (unless (file-exists-p org-directory)
      (make-directory org-directory))

    (setq org-default-notes-file (expand-file-name dotemacs-org/inbox-file))
    (setq org-log-done t)
    (setq org-log-into-drawer t)

    (setq org-startup-indented t)
    (setq org-indent-indentation-per-level 2)
    (setq org-src-fontify-natively nil)
#+END_SRC

Org is also a great way o handling TODO's, here we set some configuration and
variables to work with TODO's better. The =org-agenda-files= is set to be the
same as the =org-directory=. The =org-capture-templates= are the how to display
each entry of the possible TODO entries in the agenda (to learn more about the
agenda, visit [[https://orgmode.org/manual/Agenda-views.html#Agenda-views][the org manual on the agenda section]]). After that there are some
variables to help with TODO's.

#+BEGIN_SRC emacs-lisp :tangle config/init-org.el
    (setq org-agenda-files `(,org-directory))
    (setq org-capture-templates
          '(("t" "Todo" entry
             (file+headline (expand-file-name dotemacs-org/inbox-file) "INBOX")
             "* TODO %?\n%U\n%a\n")
            ("n" "Note" entry
             (file+headline (expand-file-name dotemacs-org/inbox-file) "NOTES")
             "* %? :NOTE:\n%U\n%a\n")
            ("m" "Meeting" entry
             (file (expand-file-name dotemacs-org/inbox-file))
             "* MEETING %? :MEETING:\n%U")
            ("j" "Journal" entry
             (file+datetree (expand-file-name dotemacs-org/journal-file))
             "* %U\n** %?")))

    (setq org-use-fast-todo-selection t)
    (setq org-treat-S-cursor-todo-selection-as-state-change nil)
    (setq org-todo-keywords
          '((sequence "TODO(t)" "NEXT(n@)" "|" "DONE(d@)")
            (sequence "WAITING(w@/!)" "|" "CANCELLED(c@/!)")))
#+END_SRC

This first variable defines what triggers an state change. After that there is
some variables that you could look up on =C-h v=. The hook after the variables
makes sure that all the inline images are redisplayed after the execution of an
src block. Lastly, the [[https://github.com/astahlman/ob-async][=ob-async=]] package allows for async execution of src
blocks if the block has =:async= in its header.

#+BEGIN_SRC emacs-lisp :tangle config/init-org.el
    (setq org-todo-state-tags-triggers
          ' (("CANCELLED" ("CANCELLED" . t))
             ("WAITING" ("WAITING" . t))
             ("TODO" ("WAITING") ("CANCELLED"))
             ("NEXT" ("WAITING") ("CANCELLED"))
             ("DONE" ("WAITING") ("CANCELLED"))))

    (setq org-refile-targets '((nil :maxlevel . 9)
                               (org-agenda-files :maxlevel . 9)))
    (setq org-refile-use-outline-path 'file)
    (setq org-outline-path-complete-in-steps nil)
    (setq org-completion-use-ido t)

    (add-hook 'org-babel-after-execute-hook #'org-redisplay-inline-images)

    (require-package 'ob-async)
    (require 'ob-async))

  (provide 'init-org)
#+END_SRC

** Proof General

[[https://proofgeneral.github.io/][Proof General]] is a generic front-end for /proof assistants/ (also known as
interactive /theorem provers/). It is installed separately via =git= and
mantained up to date via [[https://github.com/dimitri/el-get][=el-get=]].

On this first part we add to the =load-path= the path to =el-get= and
=proof-general=, so that we can load them with =require=.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (add-to-list
   'load-path (concat user-emacs-directory "el-get/el-get"))
  (add-to-list
   'load-path (concat user-emacs-directory "el-get/proof-general"))
#+END_SRC

This is the =el-get= config. First we install it if not already installed and
then setup a custom recipe for =proof-general=, because it is not one of the pre
installed recipes (for more information, see =el-get's= info page or the [[https://github.com/dimitri/el-get][README]]
on their github). We could also specify how to build ProofGeneral, but =el-get=
already does a wonderful job on figuring that out.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (require-package 'el-get)
  (require 'el-get)

  (setq el-get-sources
        '((:name proof-general
                 :type github
                 :pkgname "ProofGeneral/PG"
                 :url "https://github.com/ProofGeneral/PG.git")))
#+END_SRC

Here we check if ProofGeneral is installed or not by trying to load it and
specifying the full path it should be installed at.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (unless (load (concat user-emacs-directory
                        "el-get/proof-general/generic/proof-site.el") 'noerror)
#+END_SRC

In case it isn't installed, we set some local variables to use to install it.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
    (let* ((el-get-root
            (file-name-as-directory
             (or (bound-and-true-p el-get-dir)
                 (concat (file-name-as-directory user-emacs-directory)
                         "el-get"))))
           (package "proof-general")
           (buf (switch-to-buffer (format "*%s bootstrap*" package)))
           (pkgdir (file-name-as-directory (concat el-get-root package)))
           (git (or (executable-find "git")
                    (error "Unable to find `git'")))
           (url "https://github.com/ProofGeneral/PG.git")
           (default-directory el-get-root)
           (process-connection-type nil)) ; use pipe instead of pty
#+END_SRC

This next part is to clone ProofGeneral into the specified path =pkgdir= above.
if it fails, throw an error.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
      ;; create directory if it doesn't exist
      (unless (file-directory-p el-get-root)
        (make-directory el-get-root))

      ;; clone the package (in this case, proof general)
      (unless (zerop (funcall #'call-process git nil `(,buf t) 'display
                              "--no-pager" "clone" "-v" url package))
        (error "Couldn't clone \"%s\" from the Git repositorty: %s" package url))
#+END_SRC

If the cloning of the repository was successful, add =proof-general= to the
=load-path= and load its main file. Last, but not least, sync it with =el-get=.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
      (add-to-list 'load-path pkgdir)
      (load-file (concat pkgdir "generic/proof-site.el"))
      (load 'proof-site)
      (insert (format "Package \"%s\" loaded!" package))

  (el-get 'sync 'proof-general)))
#+END_SRC

Here is the actual configuration for ProofGeneral. First there are some settings
and then we load it.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (setq proof-strict-read-only 'retract)
  (setq proof-three-window-mode-policy 'smart)
  (setq proof-indent (symbol-value 'tab-width))
  (setq proof-splash-enable nil)
  (setq proof-script-fly-past-comments t)

  (/boot/lazy-major-mode "\\.v$" 'coq-mode)

  (require 'proof-site)
#+END_SRC

I also created an ex command for evil (the commands you type when you press =:=)
and I didn't really liked to press =C-c C-n= or =C-c C-u= all the time to
evaluate or undo the commands, so I remapped it to =M-n= and =M-p= in both
normal and insert mode.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (after 'proof-site
    (after 'evil
      (evil-ex-define-cmd "pr[ove]" 'proof-goto-point)
      (evil-define-key 'normal proof-mode-map (kbd "M-n")
        'proof-assert-next-command-interactive)
      (evil-define-key 'normal proof-mode-map (kbd "M-p")
        'proof-undo-last-successful-command)
      (evil-define-key 'normal proof-mode-map (kbd "C-n")
        'pg-next-input)
      (evil-define-key 'normal proof-mode-map (kbd "C-p")
        'pg-previous-input)
      (evil-define-key 'insert proof-mode-map (kbd "M-n")
        'proof-assert-next-command-interactive)
      (evil-define-key 'insert proof-mode-map (kbd "M-p")
        'proof-undo-last-successful-command)
      (evil-define-key 'insert proof-mode-map (kbd "C-n")
        'pg-next-input)
      (evil-define-key 'insert proof-mode-map (kbd "C-p")
        'pg-previous-input))
#+END_SRC

ProofGeneral disables =undo-tree-mode= and has it's own =pg-protected-undo=
function, that works like Emacs' undo and redo (with the difference that it
avoids breaking the locked region). I prefer to have =undo-tree's= undo and redo
(Emacs doesn't have redo, so every time I tried typing =C-r=, vim's and evil's
command for redo, it would give me an error), so I enable =undo-tree-mode=.
Also, since I use =yasnippet= I don't need =holes-mode=, so I also disable it.
The last line sync's ProofGeneral using =el-get=.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
  (add-hook
   'proof-mode-hook
   (lambda ()
     "Enable `undo-tree-mode', disable `holes-mode' and enable
    `flyspell-prog-mode' in Proof General's modes"
     (flyspell-prog-mode)
     (undo-tree-mode t)
     (holes-mode -1)))
#+END_SRC

=company-coq= is a wonderful package to work with the Coq language. It adds many
features and improves many of ProofGeneral's defaults. The last line sync's
ProofGeneral using =el-get=.

#+BEGIN_SRC emacs-lisp :tangle config/init-pg.el
    (require-package 'company-coq)
    (setq company-coq-disabled-features '(prettify-symbols smart-subscripts))
    (add-hook 'coq-mode-hook #'company-coq-mode)
    (add-hook 'company-coq-mode-hook
              (lambda ()
                (setq company-idle-delay 0.5)
                (setq coq-one-command-per-line nil))))

  (el-get 'sync 'proof-general)

  (provide 'init-pg)
#+END_SRC

** PDF

Emacs has its own PDF viewer, called =docview= (more on it on the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Document-View.html][manual]]). But
there is a lot of cool features missing. That's why I use <<target>>[[https://github.com/politza/pdf-tools][=pdf-tools=]].

=pdf-tools= configuration is pretty simple, but there is a lot of system
dependencies since it uses a server, outside Emacs, to render the PDF's as PNG
images, so that Emacs can display it in a better quality, so make sure to read
its README in the [[target][link above]].

#+BEGIN_SRC emacs-lisp :tangle config/init-pdf.el
  (/boot/delayed-init
   (require-package 'pdf-tools)
   (require 'pdf-tools)

   (unless (pdf-info-running-p)
     (pdf-tools-install)))

  ;; add this in the LaTeX part later to revert the pdf after TeX finished
  ;; compiling
  ;; (add-hook 'TeX-after-compilation-finished-functions
  ;;           #'TeX-revert-document-buffer)
#+END_SRC
