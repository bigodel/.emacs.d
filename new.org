#+TITLE: heartb1t's Emacs
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:t

* About
:PROPERTIES:
:CUSTOM_ID: about
:END:

#+BEGIN_QUOTE
No Emacs configuration is original, everything is a copy of a bunch of other
peoples' configs.

    -- Me
#+END_QUOTE

This configuration is almost a full copy of Bailey Ling's config, availabe in
[[https://github.com/bling/dotemacs][this link]]. I highly recommend you check out his config first, even though ours
do not differ much. I also recommend you to check out [[https://github.com/purcell/emacs.d][Steve Purcell's]] config. If
none of those two are your cup of tea, there is a compilation of [[https://github.com/caisah/emacs.dz][awesome emacs
configs]] to help you get started (or restarted) on you journey to create the
perfect editor.

My aim here was to use his KISS (Keep It Simple Stupid) approach to Emacs
configuration and merge it with a literate programming approach. Usually
literate programming Emacs' configuration files are one huge Org file that
tangles all of the code blocks into a single =init.el=. This can get pretty
messy pretty quick (in my opinion), so I prefer to keep a bunch of files
separate, each with their own context. For example, since =helm= is [[https://tuhdo.github.io/helm-intro.html][A Package in
a league of its own]] it makes sense to have a =config/helm-cfg.el=.

You might not want to simply copy and paste this into your configuration, I
recommend you get used to the defaults of Emacs (I'm using [[https://github.com/emacs-evil/evil][=evil-mode=]]) and
Emacs Lisp, so you can understand everything written in here. For a introduction
(a very comprehensive one) in elisp, refer to [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in
Emacs Lisp]] from the GNU Project website, or you could use the built in info by
typing =C-h i= and selecting "Emacs Lisp Intro". Also, as Sasha Chua
recommended, you could paste small portions of =elisp= code in the =*scratch*=
buffer and use the command =M-x eval buffer= to see what that code might do
without making the change permanent.

If you're viewing the Org file, you can open source code blocks (those are the
ones in =BEGIN_SRC=) in a separate buffer by moving your point inside them and
typing =C-c '= which calls the function =org-edit-special=. This opens another
buffer in =emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the
changes. If you want to explore how functions work, use =M-x edebug-defun= to
set up debugging for that function, and then call it. You can learn more about
=edebug= in the [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp manual]].

The heart of this setup lies in 3 snippets of elisp code.

The first is a wrapper on the =require= Emacs function (you can learn more about
it with =C-h f RET require=. It checks if the package is installed and if not
install it, and then uses =require= to load its libraries. This was actually
[[https://github.com/purcell/emacs.d][Purcell's]] idea, and copied from its config.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun require-package (package)
    "Ensures that PACKAGE is installed."
    (unless (or (package-installed-p package)
                (require package nil 'noerror))
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))
#+END_SRC

=with-eval-after-load= is a function that lets you defer execution of code until
after a feature has been loaded. It is very useful to only load some packages
when they're (we don't want Python related packages to be loaded when we are
hacking elisp, right?), and because of that it is extensively used in this
setup. So of course there is a macro to make it simpler. It can also run code if
a package has been installed by using "pkgname-autoloads" or only if multiple
packages have been loaded. This also avoids loading config for packages that
haven't been loaded yet, resulting in void variables of function definitions.
This was take from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]] (along with some other things).

#+BEGIN_SRC emacs-lisp :tangle no
  ;; examples
  (after 'magit
    ;; execute after magit has been loaded
    )
  (after "magit-autoloads"
    ;; execute if magit is installed/available
    )
  (after [evil magit]
    ;; execute after evil and magit have been loaded
    )

  ;; macro definiton
  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+END_SRC

The last and simplest of all is just a common lisp loop at the end of =init.el=
(the main configuration file) to recursively load all of the files ending in
=.el= inside the =config/= directory. That ensures that all of our configuration
scattered in a lot of files is loaded. If you want to add additional
configuration for a new language, simply create =new-language.el= in
=config/langs= and it will automatically be loaded. Files are loaded in reverse
order so that any functions defined will be available in child nodes.

#+BEGIN_SRC emacs-lisp :tangle no
  (cl-loop for file in (reverse
                        (directory-files-recursively config-directory "\\.el$"))
           do (load file))
#+END_SRC

Other important part (but not necessarily the heart) of the setup are the
bindings, which are all kept

* Main file

This is the main configuration file, the one that ties all of the others
together.

I start by requiring some common lisp libraries and then setting up a lexical
variable to store the start-up time for Emacs, and then display it in the
minibuffer when Emacs loads.

The next code block sets the garbage collector threshold and the =core= and
=config= directories, where our configuration files are going to be. Right after
all of the bars are disabled if they're enabled.

#+BEGIN_SRC emacs-lisp :tangle new.el
  ;;; init.el --- Init file that ties all together
  ;;; Commentary:
  ;;;
  ;;;     This serves to tie together all of the scattered configuration files.
  ;;;
  ;;; Code:

  (eval-when-compile (require 'cl))

  (lexical-let ((emacs-start-time (current-time)))
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((elapsed (float-time (time-subtract (current-time) emacs-start-time))))
                  (message "[Emacs initialized in %.3fs]" elapsed)))))

  (let ((gc-cons-threshold (* 256 1024 1024))
        (file-name-handler-alist nil)
        (core-directory (concat user-emacs-directory "core/"))
        (config-directory (concat user-emacs-directory "config/")))

    (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
#+END_SRC

These are some definitions of custom variables. They serve the purpose of
choosing what package to use for different parts of my Emacs setup, like
completion engine, which could either be =helm=, =ido= or =ivy=.

#+BEGIN_SRC emacs-lisp :tangle new.el
    (defgroup dotemacs nil
      "Custom configuration for dotemacs."
      :group 'local)

    (defcustom dotemacs-cache-directory (concat user-emacs-directory ".cache/")
      "The storage location for various persistent files."
      :type 'directory
      :group 'dotemacs)

    (defcustom dotemacs-completion-engine
      'company
      "The completion engine the use."
      :type '(radio
              (const :tag "company-mode" company)
              (const :tag "auto-complete-mode" auto-complete))
      :group 'dotemacs)

    (defcustom dotemacs-switch-engine
      'helm
      "The primary engine to use for narrowing and navigation."
      :type '(radio
              (const :tag "helm" helm)
              (const :tag "ido" ido)
              (const :tag "ivy" ivy))
      :group 'dotemacs)

    (defcustom dotemacs-pair-engine
      'emacs
      "The primary engine to use auto-pairing and parens matching."
      :type '(radio
              (const :tag "emacs" emacs)
              (const :tag "smartparens" smartparens))
      :group 'dotemacs)

    (defcustom dotemacs-globally-ignored-directories
      '("elpa" ".cache" "target" "dist" "node_modules" ".git" ".hg" ".svn" ".idea")
      "A set of default directories to ignore for anything that involves searching."
      :type '(repeat string)
      :group 'dotemacs)
#+END_SRC

Here is where we set the default repositories from where Emacs should fetch
packages from.

#+BEGIN_SRC emacs-lisp :tangle new.el
    (setq package-archives '(("melpa" . "http://melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("gnu" . "http://elpa.gnu.org/packages/")))
    (setq package-enable-at-startup nil)
    (package-initialize)
#+END_SRC

This is where we load all of our configuration files stored in
=~/.emacs.d/core=, =~/.emacs.d/config= and any custom configuration in the file
=~/.emacs.d/custom.el=. The first to be loaded is the core part, followed by the
=custom.el= file. Then there is a common lisp loop to recursively load all of
the elisp files in =~/.emacs.d/config=.

Note that if the variable =user-emacs-directory= is changed to, let's say,
=~/.myemacs=, this configuration file will look for elisp files in
=~/.myemacs/=, =~/.myemacs/core/= and =~/.myemacs/config/= instead of the above
mentioned paths with =~/.emacs.d/=.

#+BEGIN_SRC emacs-lisp :tangle new.el
    (load (concat core-directory "core-boot"))

    (setq custom-file (concat user-emacs-directory "custom.el"))
    (when (file-exists-p custom-file)
      (load custom-file))

    (cl-loop for file in (reverse (directory-files-recursively config-directory "\\.el$"))
             do (condition-case ex
                    (load (file-name-sans-extension file))
                  ('error (with-current-buffer "*scratch*"
                            (insert (format "[INIT ERROR]\n%s\n%s\n\n" file ex)))))))               (load (file-name-sans-extension file))

  (provide 'init.el) ;;; init.el ends here
#+END_SRC

* Core
** Load at boot

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (eval-when-compile (require 'cl))

  (let ((base (concat user-emacs-directory "elisp/")))
    (add-to-list 'load-path base)
    (dolist (dir (directory-files base t "^[^.]"))
      (when (file-directory-p dir)
        (add-to-list 'load-path dir))))

  (defmacro /boot/measure-load (target &rest body)
    (declare (indent defun))
    `(let ((elapsed)
           (start (current-time)))
       (prog1
           ,@body
         (with-current-buffer (get-buffer-create "*Load Times*")
           (when (= 0 (buffer-size))
             (insert (format "| %-60s | %-23s | elapsed  |\n" "feature" "timestamp"))
             (insert "|------------------------------------------+-------------------------+----------|\n"))
           (goto-char (point-max))
           (setq elapsed (float-time (time-subtract (current-time) start)))
           (insert (format "| %-60s | %s | %f |\n"
                           ,target
                           (format-time-string "%Y-%m-%d %H:%M:%S.%3N" (current-time))
                           elapsed))))))

  (defadvice load (around dotemacs activate)
    (/boot/measure-load file ad-do-it))

  (defadvice require (around dotemacs activate)
    (if (memq feature features)
        ad-do-it
      (/boot/measure-load feature ad-do-it)))

  (defmacro bind (&rest commands)
    "Convenience macro which creates a lambda interactive command."
    `(lambda (arg)
       (interactive "P")
       ,@commands))

  (defun require-package (package)
    "Ensures that PACKAGE is installed."
    (unless (or (package-installed-p package)
                (require package nil 'noerror))
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))

  (unless (fboundp 'with-eval-after-load)
    (defmacro with-eval-after-load (file &rest body)
      (declare (indent 1))
      `(eval-after-load ,file (lambda () ,@body))))

  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))

  (defmacro /boot/lazy-major-mode (pattern mode)
    "Defines a new major-mode matched by PATTERN, installs MODE if
  necessary, and activates it."
    `(add-to-list 'auto-mode-alist
                  '(,pattern . (lambda ()
                                 (require-package (quote ,mode))
                                 (,mode)))))

  (defmacro /boot/delayed-init (&rest body)
    "Runs BODY after idle for a predetermined amount of time."
    `(run-with-idle-timer
      0.5
      nil
      (lambda () ,@body)))

  (provide 'core-boot) ;;; core-boot.el ends here
#+END_SRC
