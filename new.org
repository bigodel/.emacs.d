#+TITLE: heartb1t's Emacs
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes
#+OPTIONS: toc:t

* TODO REMOVED ALL UNUSED PACKAGES!


* Introduction
:PROPERTIES:
:CUSTOM_ID: intro
:END:

#+BEGIN_QUOTE
No Emacs configuration is original, everything is a copy of a bunch of other
peoples' configs.

    -- Me
#+END_QUOTE

** About
:PROPERTIES:
:CUSTOM_ID: about
:END:

This configuration is almost a full copy of Bailey Ling's config, availabe in
[[https://github.com/bling/dotemacs][this link]]. I highly recommend you check out his config first, even though ours
do not differ much. I also recommend you to check out [[https://github.com/purcell/emacs.d][Steve Purcell's]] config. If
none of those two are your cup of tea, there is a compilation of [[https://github.com/caisah/emacs.dz][awesome emacs
configs]] to help you get started (or restarted) on you journey to create the
perfect editor.

My aim here was to use his KISS (Keep It Simple Stupid) approach to Emacs
configuration and merge it with a literate programming approach. Usually
literate programming Emacs' configuration files are one huge Org file that
tangles all of the code blocks into a single =init.el=. This can get pretty
messy pretty quick (in my opinion), so I prefer to keep a bunch of files
separate, each with their own context. For example, since =helm= is [[https://tuhdo.github.io/helm-intro.html][A Package in
a league of its own]] it makes sense to have a =config/helm-cfg.el=.

You might not want to simply copy and paste this into your configuration, I
recommend you get used to the defaults of Emacs (I'm using [[https://github.com/emacs-evil/evil][evil-mode]]) and
Emacs Lisp, so you can understand everything written in here. For a introduction
(a very comprehensive one) in elisp, refer to [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in
Emacs Lisp]] from the GNU Project website, or you could use the built in info by
typing =C-h i= and selecting "Emacs Lisp Intro". Also, as Sasha Chua
recommended, you could paste small portions of =elisp= code in the =*scratch*=
buffer and use the command =M-x eval buffer= to see what that code might do
without making the change permanent.

If you're viewing the Org file, you can open source code blocks (those are the
ones in =BEGIN_SRC=) in a separate buffer by moving your point inside them and
typing =C-c '= which calls the function =org-edit-special=. This opens another
buffer in =emacs-lisp-mode=, so you can use =M-x eval-buffer= to load the
changes. If you want to explore how functions work, use =M-x edebug-defun= to
set up debugging for that function, and then call it. You can learn more about
=edebug= in the [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Edebug.html][Emacs Lisp manual]].

** Tools
:PROPERTIES:
:CUSTOM_ID: tools
:END:

The heart of this setup lies in 3 snippets of elisp/common lisp code.

*** =require-package=
:PROPERTIES:
:CUSTOM_ID: require-pkg
:END:

The first is a wrapper on the =require= Emacs function (you can learn more about
it with =C-h f RET require=. It checks if the package is installed and if not
install it, and then uses =require= to load its libraries. This was actually
[[https://github.com/purcell/emacs.d][Purcell's]] idea, and copied from its config.

#+BEGIN_SRC emacs-lisp :tangle no
  (defun require-package (package)
    "Ensures that PACKAGE is installed."
    (unless (or (package-installed-p package)
                (require package nil 'noerror))
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))
#+END_SRC

*** =after=
:PROPERTIES:
:CUSTOM_ID: after
:END:

=with-eval-after-load= is a function that lets you defer execution of code until
after a feature has been loaded. It is very useful to only load some packages
when they're (we don't want Python related packages to be loaded when we are
hacking elisp, right?), and because of that it is extensively used in this
setup. So of course there is a macro to make it simpler. It can also run code if
a package has been installed by using "pkgname-autoloads" or only if multiple
packages have been loaded. This also avoids loading config for packages that
haven't been loaded yet, resulting in void variables of function definitions.
This was take from [[http://milkbox.net/note/single-file-master-emacs-configuration/][milkypostman]] (along with some other things).

#+BEGIN_SRC emacs-lisp :tangle no
  ;; examples
  (after 'magit
    ;; execute after magit has been loaded
    )
  (after "magit-autoloads"
    ;; execute if magit is installed/available
    )
  (after [evil magit]
    ;; execute after evil and magit have been loaded
    )

  ;; macro definiton
  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+END_SRC

*** Bootstrap
:PROPERTIES:
:CUSTOM_ID: bootstrap
:END:

The last and simplest of all is just a common lisp loop at the end of =init.el=
(the main configuration file) to recursively load all of the files ending in
=.el= inside the =config/= directory. That ensures that all of our configuration
scattered in a lot of files is loaded. If you want to add additional
configuration for a new language, simply create =new-language.el= in
=config/langs= and it will automatically be loaded. Files are loaded in reverse
order so that any functions defined will be available in child nodes.

#+BEGIN_SRC emacs-lisp :tangle no
  (cl-loop for file in (reverse
                        (directory-files-recursively config-directory "\\.el$"))
           do (load file))
#+END_SRC

*** Bindings
:PROPERTIES:
:CUSTOM_ID: bindings
:END:

Other important part (but not necessarily the heart) of the setup are the
bindings, which are mostly kept on the =config/config-bindings.el=. Some
packages and modes have too much bindings, so they have their own specific
bindings file under the =config/bindings= directory. Because of this, things
like =use-package= aren't particularly useful here because it doesn't add much
value over =require-package= and =after=.

Keybindings are the single most differentiating factor between configs. By
defining them in one place, if you want to use/fork this config, you can simply
change the bindings to your liking and still use all the other pre-configured
packages as is. If you're not an =evil= user, delete =config-evil.el= and you
will get a pure Emacs experience.

*** Lazy major modes
:PROPERTIES:
:CUSTOM_ID: lazy-major-modes
:END:

Another important part is that by combining =after=, =require-package= and
=auto-mode-alist=, packages are only installed when needed. So python packages
are only installed if a python file is opened (and so for any other language).
If you never open a python file, none of the python specific packages will ever
be installed.


* Main file

This is the main configuration file, the one that ties all of the others
together.

I start by requiring some common lisp libraries and then setting up a lexical
variable to store the start-up time for Emacs, and then display it in the
minibuffer when Emacs loads.

The next code block sets the garbage collector threshold and the =core= and
=config= directories, where our configuration files are going to be. Right after
all of the bars are disabled if they're enabled.

#+BEGIN_SRC emacs-lisp :tangle new.el
  (eval-when-compile (require 'cl))

  (lexical-let ((emacs-start-time (current-time)))
    (add-hook 'emacs-startup-hook
              (lambda ()
                (let ((elapsed (float-time (time-subtract (current-time) emacs-start-time))))
                  (message "[ Emacs initialized in %.3fs ]" elapsed)))))

  (let ((gc-cons-threshold (* 256 1024 1024))
        (file-name-handler-alist nil)
        (core-directory (concat user-emacs-directory "core/"))
        (config-directory (concat user-emacs-directory "config/")))

    (when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
    (when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
    (when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
    (when (fboundp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
#+END_SRC

These are some definitions of custom variables. They serve the purpose of
choosing what package to use for different parts of my Emacs setup, like
completion engine, which could either be =helm=, =ido= or =ivy=.

#+TΟDO: switch this to init.el
#+BEGIN_SRC emacs-lisp :tangle new.el
  (defgroup dotemacs nil
    "Custom configuration for dotemacs."
    :group 'local)

  (defcustom dotemacs-cache-directory (concat user-emacs-directory ".cache/")
    "The storage location for various persistent files."
    :type 'directory
    :group 'dotemacs)

  (defcustom dotemacs-completion-engine
    'company
    "The completion engine the use."
    :type '(radio
            (const :tag "company-mode" company)
            (const :tag "auto-complete-mode" auto-complete))
    :group 'dotemacs)

  (defcustom dotemacs-switch-engine
    'helm
    "The primary engine to use for narrowing and navigation."
    :type '(radio
            (const :tag "helm" helm)
            (const :tag "ido" ido)
            (const :tag "ivy" ivy))
    :group 'dotemacs)

  (defcustom dotemacs-pair-engine
    'emacs
    "The primary engine to use auto-pairing and parens matching."
    :type '(radio
            (const :tag "emacs" emacs)
            (const :tag "smartparens" smartparens))
    :group 'dotemacs)

  (defcustom dotemacs-globally-ignored-directories
    '("elpa" ".cache" "target" "dist" "node_modules" ".git" ".hg" ".svn" ".idea")
    "A set of default directories to ignore for anything that involves searching."
    :type '(repeat string)
    :group 'dotemacs)
#+END_SRC

Here is where we set the default repositories from where Emacs should fetch
packages from.

#+BEGIN_SRC emacs-lisp :tangle new.el
    (setq package-archives '(("melpa" . "http://melpa.org/packages/")
                             ("org" . "http://orgmode.org/elpa/")
                             ("gnu" . "http://elpa.gnu.org/packages/")))
    (setq package-enable-at-startup nil)
    (package-initialize)
#+END_SRC

This is where we load all of our configuration files stored in
=~/.emacs.d/core=, =~/.emacs.d/config= and any custom configuration in the file
=~/.emacs.d/custom.el=. The first to be loaded is the core part, followed by the
=custom.el= file. Then there is a common lisp loop to recursively load all of
the elisp files in =~/.emacs.d/config=.

Note that if the variable =user-emacs-directory= is changed to, let's say,
=~/.myemacs=, this configuration file will look for elisp files in
=~/.myemacs/=, =~/.myemacscore/core-= and =~/.myemacs/config/= instead of the above
mentioned paths with =~/.emacs.d/=.

#+BEGIN_SRC emacs-lisp :tangle new.el
    (load (concat core-directory "core-boot"))

    (setq custom-file (concat user-emacs-directory "custom.el"))
    (when (file-exists-p custom-file)
      (load custom-file))

    (cl-loop for file in (reverse (directory-files-recursively config-directory "\\.el$"))
             do (condition-case ex
                    (load (file-name-sans-extension file))
                  ('error (with-current-buffer "*scratch*"
                            (insert (format "[INIT ERROR]\n%s\n%s\n\n" file ex)))))))               (load (file-name-sans-extension file))

  (provide 'init.el) ;;; init.el ends here
#+END_SRC


* Core
:PROPERTIES:
:CUSTOM_ID: core
:END:
** Load at boot
:PROPERTIES:
:CUSTOM_ID: core-boot
:END:

We also load the common lisp libraries here.

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (eval-when-compile (require 'cl))
#+END_SRC

Load any manually installed packages on the =elisp/= directory.

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (let ((base (concat user-emacs-directory "elisp/")))
    (add-to-list 'load-path base)
    (dolist (dir (directory-files base t "^[^.]"))
      (when (file-directory-p dir)
        (add-to-list 'load-path dir))))
#+END_SRC

This handy macro creates a new buffer with the name =*Load Times*= and shows a
moderately detailed information about the load time of TARGET. It is used here
to show the load times of packages loaded with =require= or =load=.

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (defmacro /boot/measure-load (target &rest body)
    (declare (indent defun))
    `(let ((elapsed)
           (start (current-time)))
       (prog1
           ,@body
         (with-current-buffer (get-buffer-create "*Load Times*")
           (when (= 0 (buffer-size))
             (insert (format "| %-60s | %-23s | elapsed  |\n" "feature" "timestamp"))
             (insert "|------------------------------------------+-------------------------+----------|\n"))
           (goto-char (point-max))
           (setq elapsed (float-time (time-subtract (current-time) start)))
           (insert (format "| %-60s | %s | %f |\n"
                           ,target
                           (format-time-string "%Y-%m-%d %H:%M:%S.%3N" (current-time))
                           elapsed))))))

  (defadvice load (around dotemacs activate)
    (/boot/measure-load file ad-do-it))

  (defadvice require (around dotemacs activate)
    (if (memq feature features)
        ad-do-it
      (/boot/measure-load feature ad-do-it)))

  (defmacro bind (&rest commands)
    "Convenience macro which creates a lambda interactive command."
    `(lambda (arg)
       (interactive "P")
       ,@commands))
#+END_SRC

Here are the macros mentioned on the [[#intro][introduction]] section.

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (defun require-package (package)
    "Ensures that PACKAGE is installed."
    (unless (or (package-installed-p package)
                (require package nil 'noerror))
      (unless (assoc package package-archive-contents)
        (package-refresh-contents))
      (package-install package)))

  (unless (fboundp 'with-eval-after-load)
    (defmacro with-eval-after-load (file &rest body)
      (declare (indent 1))
      `(eval-after-load ,file (lambda () ,@body))))

  (defmacro after (feature &rest body)
    "Executes BODY after FEATURE has been loaded.

  FEATURE may be any one of:
      'evil            => (with-eval-after-load 'evil BODY)
      \"evil-autoloads\" => (with-eval-after-load \"evil-autolaods\" BODY)
      [evil cider]     => (with-eval-after-load 'evil
                            (with-eval-after-load 'cider
                              BODY))
  "
    (declare (indent 1))
    (cond
     ((vectorp feature)
      (let ((prog (macroexp-progn body)))
        (cl-loop for f across feature
                 do
                 (progn
                   (setq prog (append `(',f) `(,prog)))
                   (setq prog (append '(with-eval-after-load) prog))))
        prog))
     (t
      `(with-eval-after-load ,feature ,@body))))
#+END_SRC

The first macro is to lazily install a major mode like described in [[#lazy-major-modes][Lazy major
modes]]. The second one is self explanatory.

#+BEGIN_SRC emacs-lisp :tangle core/core-boot.el
  (defmacro /boot/lazy-major-mode (pattern mode)
    "Defines a new major-mode matched by PATTERN, installs MODE if
  necessary, and activates it."
    `(add-to-list 'auto-mode-alist
                  '(,pattern . (lambda ()
                                 (require-package (quote ,mode))
                                 (,mode)))))

  (defmacro /boot/delayed-init (&rest body)
    "Runs BODY after idle for a predetermined amount of time."
    `(run-with-idle-timer
      0.5
      nil
      (lambda () ,@body)))

  (provide 'core-boot) ;;; core-boot.el ends here
#+END_SRC


* Config
:PROPERTIES:
:CUSTOM_ID: cfg
:END:

This is the section where configuration actually takes place.

** Core
:PROPERTIES:
:CUSTOM_ID: cfg-core
:END:

Here we place some core configurations, without depending on any package. Just
some default Emacs config.

First we create a group to keep all the core configuration together in one
place. And them define a customizable variable for the coding system, which is
UTF-8 by default.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (defgroup dotemacs-core nil
    "Configuration options for core Emacs functionality."
    :group 'dotemacs
    :prefix 'dotemacs-core)

  (defcustom dotemacs-core/default-coding-system
    'utf-8
    "The default coding system to use."
    :type '(radio
            (const :tag "utf-8" utf-8)
            (const :tag "utf-8-dos" utf-8-dos)
            (const :tag "utf-8-unix" utf-8-unix))
    :group 'dotemacs-core)
#+END_SRC

This setting sets the default location for the Emacs socket to be in and then
initializes the server if it is not already running.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (defcustom dotemacs-core/server-directory
    (format "%s/emacs%d/" (or (getenv "TMPDIR") "/tmp") (user-uid))
    "The storage location for the socket file used to connect to the daemon."
    :type 'directory
    :group 'dotemacs-core)
  (setq server-socket-dir dotemacs-core/server-directory)
  (setq server-auth-dir (concat dotemacs-core/server-directory "server"))
  (require 'server)
  (unless (server-running-p)
    (server-start))
#+END_SRC

This function is to create a ask to create a directory if trying to access a
non-existing directory.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (defun /core/create-non-existent-directory ()
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
        (make-directory parent-directory t))))

  (add-to-list 'find-file-not-found-functions #'/core/create-non-existent-directory)
#+END_SRC

=saveplace= is a minor mode that automatically saves place in each file. This
means when you visit a file, point goes to the last place where it was when you
previously visited the same file. =savehist-mode= save the minibuffer history in
the file defined by =savehist-file=. And =recentf= displays recently visited
files (excluding some temporary files we don't want to revisit).

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  ;; move cursor to the last position upon open
  (require 'saveplace)
  (setq save-place-file (concat dotemacs-cache-directory "places"))
  (save-place-mode t)

  ;; savehist
  (setq savehist-file (concat dotemacs-cache-directory "savehist")
        savehist-additional-variables '(search ring regexp-search-ring)
        savehist-autosave-interval 60
        history-length 1000)
  (savehist-mode t)

  ;; recent files
  (require 'recentf)
  (setq recentf-save-file (concat dotemacs-cache-directory "recentf"))
  (setq recentf-max-saved-items 1000)
  (setq recentf-max-menu-items 500)
  (setq recentf-auto-cleanup 300)
  (add-to-list 'recentf-exclude "COMMIT_EDITMSG\\'")
  (add-to-list 'recentf-exclude ".*elpa.*autoloads\.el$")
  (recentf-mode t)
  (run-with-idle-timer 600 t #'recentf-save-list)
#+END_SRC

These configurations are regarding garbage collection on Emacs. I mostly took it
from [[http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][this]] post.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  ;; gc
  (defun /core/minibuffer-setup-hook ()
    (setq gc-cons-threshold most-positive-fixnum))
  (defun /core/minibuffer-exit-hook ()
    (setq gc-cons-threshold (* 64 1024 1024)))
  (add-hook 'minibuffer-setup-hook #'/core/minibuffer-setup-hook)
  (add-hook 'minibuffer-exit-hook #'/core/minibuffer-exit-hook)
#+END_SRC

Here we configure the behavior of some default Emacs functions. If you'd like to
take a look at what they do you could =C-h f= (or =C-h a=) and type the name of
the function (the comment right before the config) or search on the web, but I
recommend you look the default documentation about it on Emacs first.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  ;; pcomplete
  (setq pcomplete-ignore-case t)

  ;; imenu
  (setq-default imenu-auto-rescan t)

  ;; narrowing
  (put 'narrow-to-region 'disabled nil)

  ;; dired
  (after 'dired
         (require 'dired-x))

  ;; url
  (setq url-configuration-directory (concat dotemacs-cache-directory "url/"))

  ;; tramp
  (setq tramp-persistency-file-name (concat dotemacs-cache-directory "tramp"))
  (setq tramp-default-method "ssh")
  (setq remote-file-name-inhibit-cache nil)
  (setq vc-ignore-dir-regexp
        (format "%s\\|%s"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
  ;; TODO: review this
  ;;(eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))

  ;; comint
  (after 'comint
         (defun /core/toggle-comint-scroll-to-bottom-on-output ()
           (interactive)
           (if comint-scroll-to-bottom-on-output
               (setq comint-scroll-to-bottom-on-output nil)
             (setq comint-scroll-to-bottom-on-output t))))

  ;; compile
  (setq compilation-always-kill t)
  (setq compilation-ask-about-save nil)
  (add-hook 'compilation-filter-hook
            (lambda ()
              (when (eq major-mode 'compilation-mode)
                (require 'ansi-color)
                (let ((inhibit-read-only t))
                  (ansi-color-apply-on-region (point-min) (point-max))))))

  ;; bookmarks
  (setq bookmark-default-file (concat dotemacs-cache-directory "bookmarks"))
  (setq bookmark-save-flag 1) ;; save after every change

  ;; fringe
  (when (display-graphic-p)
    (fringe-mode '(2 . 0)))

  ;; ediff
  (setq ediff-split-window-function 'split-window-horizontally) ;; side-by-side diffs
  (setq ediff-window-setup-function 'ediff-setup-windows-plain) ;; no extra frames

  ;; re-builder
  (setq reb-re-syntax 'string) ;; fix backslash madness

  ;; clean up old buffers periodically
  (midnight-mode)
  (midnight-delay-set 'midnight-delay 0)

  ;; ibuffer
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode)

  ;; move auto-save to the cache
  (let ((dir (expand-file-name (concat dotemacs-cache-directory "auto-save/"))))
    (setq auto-save-list-file-prefix (concat dir "saves-"))
    (setq auto-save-file-name-transforms `((".*" ,(concat dir "save-") t))))

  ;; multiple-backups
  (setq backup-directory-alist `((".*" . ,(expand-file-name (concat dotemacs-cache-directory "backups/")))))
  (setq backup-by-copying t)
  (setq version-control t)
  (setq kept-old-versions 0)
  (setq kept-new-versions 20)
  (setq delete-old-versions t)

  ;; better scrolling
  (setq scroll-conservatively 9999
        scroll-preserve-screen-position t
        scroll-margin 3)

  ;; better buffer names for duplicates
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator "/"
        uniquify-ignore-buffers-re "^\\*" ; leave special buffers alone
        uniquify-after-kill-buffer-p t)

  (defun /core/do-not-kill-scratch-buffer ()
    (if (member (buffer-name (current-buffer))
                '("*scratch*" "*Messages*" "*Require Times*"))
        (progn
          (bury-buffer)
          nil)
      t))
  (add-hook 'kill-buffer-query-functions '/core/do-not-kill-scratch-buffer)
#+END_SRC

Change the "yes or no" prompt to "y-or-n", set the coding system based on the
custom variable we defined above and set some variables value.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (defalias 'yes-or-no-p 'y-or-n-p)

  (let ((coding dotemacs-core/default-coding-system))
    (setq locale-coding-system coding)
    (set-selection-coding-system coding)
    (set-default-coding-systems coding)
    (prefer-coding-system coding)
    (setq-default buffer-file-coding-system coding))

  (setq sentence-end-double-space nil)
  (setq ring-bell-function 'ignore)
  (setq mark-ring-max 64)
  (setq global-mark-ring-max 128)
  (setq save-interprogram-paste-before-kill t)
  (setq create-lockfiles nil)
  (setq echo-keystrokes 0.01)
  (setq initial-major-mode 'emacs-lisp-mode)
  (setq eval-expression-print-level nil)
#+END_SRC

These are some configurations regarding indentation.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (setq-default indent-tabs-mode nil) ;; spaces instead of tabs
  (setq-default tab-width 4)

  (defun /core/infer-indentation-style ()
    "If our source file uses tabs, we use tabs, if spaces spaces,
  and if neither, we use the current indent-tabs-mode"
    (let ((space-count (how-many "^  " (point-min) (point-max)))
          (tab-count (how-many "^\t" (point-min) (point-max))))
      (if (> space-count tab-count) (setq indent-tabs-mode nil))
      (if (> tab-count space-count) (setq indent-tabs-mode t))))

  (add-hook 'prog-mode-hook #'/core/infer-indentation-style)
#+END_SRC

Do not show the initial default splash screen and do not show any message on
start-up.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (setq inhibit-splash-screen t)
  (setq inhibit-startup-echo-area-message t)
  (setq inhibit-startup-message t)
#+END_SRC

Some modes that I like to have by default.

#+BEGIN_SRC emacs-lisp :tangle config/config-core.el
  (global-visual-line-mode)
  (xterm-mouse-mode t)
  (which-function-mode t)
  (blink-cursor-mode -1)
  (global-auto-revert-mode t)
  (electric-indent-mode t)
  (transient-mark-mode t)
  (delete-selection-mode t)
  (random t) ;; seed

  (defun /core/find-file-hook ()
    (when (string-match "\\.min\\." (buffer-file-name))
      (fundamental-mode)))
  (add-hook 'find-file-hook #'/core/find-file-hook)

  (provide 'config-core)
#+END_SRC

** Util
:PROPERTIES:
:CUSTOM_ID: cfg-util
:END:

Some useful functions. They are pretty much self documented, so there ain't much
more I could say about it.

#+BEGIN_SRC emacs-lisp :tangle config/config-util.el
  (defun /util/window-killer ()
    "Closes the window, and deletes the buffer if it's the last window open."
    (interactive)
    (if (> buffer-display-count 1)
        (if (= (length (window-list)) 1)
            (kill-buffer)
          (delete-window))
      (kill-buffer-and-window)))

  (defun /util/minibuffer-keyboard-quit ()
    "Abort recursive edit.
  In Delete Selection mode, if the mark is active, just deactivate it;
  then it takes a second \\[keyboard-quit] to abort the minibuffer."
    (interactive)
    (if (and delete-selection-mode transient-mark-mode mark-active)
        (setq deactivate-mark t)
      (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
      (abort-recursive-edit)))

  (defun /util/set-transparency (alpha)
    "Sets the transparency of the current frame."
    (interactive "nAlpha: ")
    (set-frame-parameter nil 'alpha alpha))

  (defun /util/copy-file-name-to-clipboard ()
    "Copy the current buffer file name to the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (kill-new filename)
        (message "Copied buffer file name '%s' to the clipboard." filename))))

  (defun /util/eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (let ((value (eval (preceding-sexp))))
      (backward-kill-sexp)
      (insert (format "%s" value))))

  (defun /util/rename-current-buffer-file ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer is not visiting a file!")
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))

  (defun /util/delete-current-buffer-file ()
    "Kill the current buffer and deletes the file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (if (vc-backend filename)
            (vc-delete-file filename)
          (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
            (delete-file filename)
            (message "Deleted file %s" filename)
            (kill-buffer))))))

  (defun /util/goto-scratch-buffer ()
    "Create a new scratch buffer."
    (interactive)
    (switch-to-buffer (get-buffer-create "*scratch*")))

  (defun /util/insert-last-kbd-macro ()
    (interactive)
    (name-last-kbd-macro 'my-last-macro)
    (insert-kbd-macro 'my-last-macro))

  (defun /util/set-buffer-to-unix-format ()
    "Converts the current buffer to UNIX file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix nil))

  (defun /util/set-buffer-to-dos-format ()
    "Converts the current buffer to DOS file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (defun /util/find-file-as-root (file)
    "Edits a file as root."
    (interactive "f")
    (find-file-other-window (concat "/sudo:root@localhost:" file)))

  (defun /util/insert-line-below ()
    "Insert a line below the cursor without moving point."
    (interactive)
    (let ((current-point (point)))
      (move-end-of-line 1)
      (open-line 1)
      (goto-char current-point)))

  (defun /util/insert-line-above ()
    "Insert a line above the cursor without moving point."
    (interactive)
    (let ((current-point (point)))
      (move-beginning-of-line 1)
      (newline-and-indent)
      (indent-according-to-mode)
      (goto-char current-point)
      (forward-char)))

  (provide 'config-util)
#+END_SRC

** Evil
:PROPERTIES:
:CUSTOM_ID: cfg-evil
:END:

Probably my most used packages, by far.

#+BEGIN_SRC emacs-lisp :tangle config/config-evil.el
  (defgroup dotemacs-evil nil
    "Configuration options for evil-mode."
    :group 'dotemacs
    :prefix 'dotemacs-evil)

  (defcustom dotemacs-evil/emacs-state-hooks
    '(org-log-buffer-setup-hook org-capture-mode-hook)
    "List of hooks to automatically start up in Evil Emacs state."
    :type '(repeat (symbol))
    :group 'dotemacs-evil)

  (defcustom dotemacs-evil/emacs-state-major-modes
    '(calculator-mode
      eshell-mode
      makey-key-mode)
    "List of major modes that should default to Emacs state."
    :type '(repeat (symbol))
    :group 'dotemacs-evil)

  (defcustom dotemacs-evil/emacs-state-minor-modes
    '(git-commit-mode
      magit-blame-mode)
    "List of minor modes that when active should switch to Emacs state."
    :type '(repeat (symbol))
    :group 'dotemacs-evil)

  (defcustom dotemacs-evil/emacs-insert-mode
    nil
    "If non-nil, insert mode will act as Emacs state."
    :type 'boolean
    :group 'dotemacs-evil)

  (defcustom dotemacs-evil/comments
    'evil-nerd-commenter
    "The library to use for comments."
    :type '(radio
            (const :tag "evil-nerd-commenter" evil-nerd-commenter)
            (const :tag "evil-commentary" evil-commentary))
    :group 'dotemacs-evil)
#+END_SRC

Some variable configuration for =evil= to feel more like (n)vim.

#+BEGIN_SRC emacs-lisp :tangle config/config-evil.el
  (setq evil-search-module 'evil-search)
  (setq evil-magic 'very-magic)
  (setq evil-shift-width 4)
  (setq evil-regexp-search t)
  (setq evil-search-wrap t)
  (setq evil-want-C-i-jump t)
  (setq evil-want-C-u-scroll t)
  (setq evil-want-fine-undo nil)
  (setq evil-want-integration nil)
#+END_SRC

I usually know in what =evil= state I'm in by the cursor color because of the
configuration.

#+BEGIN_SRC emacs-lisp :tangle config/config-evil.el
  (setq evil-emacs-state-cursor '("red" box))
  (setq evil-motion-state-cursor '("white" box))
  (setq evil-normal-state-cursor '("magenta" box))
  (setq evil-visual-state-cursor '("orange" box))
  (setq evil-insert-state-cursor '("red" bar))
  (setq evil-replace-state-cursor '("red" hbar))
  (setq evil-operator-state-cursor '("red" hollow))
#+END_SRC

Here is where I actually start =evil= after setting some more variables and
hooks. Also in this code snippet is where all of the lists of default states for
some modes set above are actually set with a common lisp loop.

#+BEGIN_SRC emacs-lisp :tangle config/config-evil.el
  (add-hook 'evil-jumps-post-jump-hook #'recenter)

  (require-package 'evil)
  (require 'evil)
  (evil-mode)

  (cl-loop for mode in dotemacs-evil/emacs-state-minor-modes
           do (let ((hook (concat (symbol-name mode) "-hook")))
                (add-hook (intern hook) `(lambda ()
                                           (if ,mode
                                               (evil-emacs-state)
                                             (evil-normal-state))))))

  (cl-loop for hook in dotemacs-evil/emacs-state-hooks
           do (add-hook hook #'evil-emacs-state))

  (cl-loop for mode in dotemacs-evil/emacs-state-major-modes
           do (evil-set-initial-state mode 'emacs))

  (after 'evil-common
         (evil-put-property 'evil-state-properties 'normal   :tag " NORMAL ")
         (evil-put-property 'evil-state-properties 'insert   :tag " INSERT ")
         (evil-put-property 'evil-state-properties 'visual   :tag " VISUAL ")
         (evil-put-property 'evil-state-properties 'motion   :tag " MOTION ")
         (evil-put-property 'evil-state-properties 'emacs    :tag " EMACS ")
         (evil-put-property 'evil-state-properties 'replace  :tag " REPLACE ")
         (evil-put-property 'evil-state-properties 'operator :tag " OPERATOR "))

  (when dotemacs-evil/emacs-insert-mode
    (defalias 'evil-insert-state 'evil-emacs-state)
    (define-key evil-emacs-state-map (kbd "<escape>") 'evil-normal-state))

  (unless (display-graphic-p)
    (evil-esc-mode 1))
#+END_SRC

Here is the configuration for the comment package. And some more additional
packages to help integrate =evil= into the most modes possible.

#+BEGIN_SRC emacs-lisp :tangle config/config-evil.el
  (cond
   ((eq dotemacs-evil/comments 'evil-commentary)
    (require-package 'evil-commentary)
    (evil-commentary-mode t))
   ((eq dotemacs-evil/comments 'evil-nerd-commenter)
    (require-package 'evil-nerd-commenter)
    (require 'evil-nerd-commenter)
    (require 'evil-nerd-commenter-operator)
    (define-key evil-inner-text-objects-map evilnc-comment-text-object 'evilnc-inner-comment)
    (define-key evil-outer-text-objects-map evilnc-comment-text-object 'evilnc-outer-commenter)
    (define-key evil-normal-state-map "gc" 'evilnc-comment-operator)
    (define-key evil-normal-state-map "gy" 'evilnc-copy-and-comment-operator)))

  (require-package 'evil-surround)
  (global-evil-surround-mode t)

  (require-package 'evil-exchange)
  (evil-exchange-install)

  (require-package 'evil-anzu)
  (require 'evil-anzu)

  (after 'magit
         (require-package 'evil-magit)
         (require 'evil-magit))

  (after 'org
         (require-package 'evil-org)
         (require 'evil-org)
         (add-hook 'org-mode-hook 'evil-org-mode)
         (add-hook 'evil-org-mode-hook
                   (lambda ()
                     (evil-org-set-key-theme))))

  (require-package 'evil-avy)
  (evil-avy-mode)

  (require-package 'evil-matchit)
  (defun evilmi-customize-keybinding ()
    (evil-define-key 'normal evil-matchit-mode-map
      "%" 'evilmi-jump-items))
  (global-evil-matchit-mode t)

  (require-package 'evil-indent-textobject)
  (require 'evil-indent-textobject)

  (require-package 'evil-visualstar)
  (global-evil-visualstar-mode t)

  (require-package 'evil-numbers)

  (require-package 'evil-terminal-cursor-changer)
  (evil-terminal-cursor-changer-activate)

  (defadvice evil-ex-search-next (after dotemacs activate)
    (recenter))

  (defadvice evil-ex-search-previous (after dotemacs activate)
    (recenter))

  (provide 'config-evil)
#+END_SRC

** Helm

Helm is a /Emacs incremental completion and selection narrowing framework/
https://emacs-helm.github.io/helm.

#+BEGIN_QUOTE
People often think helm is just something like [[https://www.emacswiki.org/emacs/InteractivelyDoThings][=ido=]] but displaying
completion in a vertical layout instead of an horizontal one, it is not,
helm is much more powerful than that.

  + Helm is able to complete multiple lists dispatched in different sources against a pattern.

  + Helm allows executing an unlimited number of actions on candidates.

  + Helm allows marking candidates to execute chosen action against this set of candidates.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle config/config-helm.el
  (require-package 'helm)

  (setq helm-bookmark-show-location t)
  (setq helm-buffer-max-length 40)

  (after 'helm-source
    (defun /helm/make-source (f &rest args)
      (let ((source-type (cadr args))
            (props (cddr args)))
        (unless (child-of-class-p source-type 'helm-source-async)
          (plist-put props :fuzzy-match t))
        (apply f args)))
    (advice-add 'helm-make-source :around '/helm/make-source))
#+END_SRC

Helm also has a lot of other packages to integrate it to other packages and
parts of Emacs that the default package doesn't cover. Here are some of those.

#+BEGIN_SRC emacs-lisp :tangle config/config-helm.el
    (after 'helm
           (require-package 'helm-descbinds)

           (require-package 'helm-flx)
           (helm-flx-mode t)

           (require-package 'helm-dash)
           (setq helm-dash-browser-func 'eww)

           (require-package 'helm-ag)
           (setq helm-ag-fuzzy-match t)
           (setq helm-ag-use-agignore t)
           (setq helm-ag-ignore-patterns dotemacs-globally-ignored-directories)
           (after 'helm-ag
                  (cond ((executable-find "ag")
                         t)
                        ((executable-find "pt")
                         (setq helm-ag-base-command "pt -e --nogroup --nocolor"))
                        ((executable-find "ack")
                         (setq helm-ag-base-command "ack --nogroup --nocolor"))))

           (setq helm-swoop-pre-input-function #'ignore)
           (setq helm-swoop-use-line-number-face t)
           (setq helm-swoop-split-with-multiple-windows t)
           (setq helm-swoop-speed-or-color t)
           (setq helm-swoop-use-fuzzy-match t)
           (require-package 'helm-swoop)

           (after "projectile-autoloads"
                  (require-package 'helm-projectile))

           (require-package 'helm-tramp)

           ;; take between 10-30% of screen space
           (setq helm-autoresize-min-height 10)
           (setq helm-autoresize-max-height 30)
           (helm-autoresize-mode t))
#+END_SRC

Decide if helm is the wanted switch engine or not.

#+BEGIN_SRC emacs-lisp :tangle config/config-helm.el
    (defun /helm/activate-as-switch-engine (on)
      (if on
          (progn
            (global-set-key [remap execute-extended-command] #'helm-M-x)
            (global-set-key [remap find-file] #'helm-find-files)
            (helm-mode t))
        (global-set-key [remap execute-extended-command] nil)
        (global-set-key [remap find-file] nil)
        (helm-mode -1)))

    (when (eq dotemacs-switch-engine 'helm)
      (/boot/delayed-init
       (/helm/activate-as-switch-engine t)))

    (provide 'config-helm)
#+END_SRC

** Eyecandy
:PROPERTIES:
:CUSTOM_ID: cfg-eyecandy
:END:

Some eyecandy is good.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (defgroup dotemacs-eyecandy nil
    "Configuration options for eye candy."
    :group 'dotemacs
    :prefix 'dotemacs-eyecandy)

  (defcustom dotemacs-eyecandy/mode-line
    'sml
    "List of hooks to automatically start up in Evil Emacs state."
    :type '(radio
            (const :tag "smart mode line" sml)
            (const :tag "spaceline" spaceline))
    :group 'dotemacs-eyecandy)

  (defcustom dotemacs-eyecandy/folding
    'origami
    "The library to use for folding."
    :type '(radio
            (const :tag "origami" origami)
            (const :tag "hide-show" hide-show))
    :group 'dotemacs-eyecandy)

  (defcustom dotemacs-eyecandy/color-theme
    'default
    "Emacs color theme."
    :type '(radio
            (const :tag "default" manjo-dark)
            (const :tag "sanityinc-tomorrow-bright" sanityinc-tomorrow-bright)
            (const :tag "gruvbox-dark-hard" gruvbox-dark-hard))
    :group 'dotemacs-eyecandy)
#+END_SRC

Color theme config.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (cond
   ;; default color theme
   ((eq dotemacs-eyecandy/color-theme 'default)
    (load-theme 'manoj-dark t))
   ;; tomorrow bright
   ((eq dotemacs-eyecandy/color-theme 'sanityinc-tomorrow-bright)
    (require-package 'color-theme-sanityinc-tomorrow)
    (load-theme 'sanityinc-tomorrow-bright t))
   ;; gruvbox dark
   ((eq dotemacs-eyecandy/color-theme 'gruvbox-dark-hard)
    (require-package 'gruvbox-theme)
    (load-theme 'gruvbox-dark-hard t)))
#+END_SRC

If the selected pair engine is Emacs, then activate =show-paren-mode= and set
its delay to 0. Also there is some mode to display stuff in the modeline that
are very useful.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (when (eq dotemacs-pair-engine 'emacs)
    (show-paren-mode)
    (setq show-paren-delay 0))

  (line-number-mode t)
  (column-number-mode t)
  (display-time-mode t)
  (size-indication-mode t)
#+END_SRC

Here is the configuration regarding the preferred folding method.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (cond
   ((eq dotemacs-eyecandy/folding 'origami)
    (progn
      (require-package 'origami)
      (global-origami-mode)))
   ((eq dotemacs-eyecandy/folding 'hide-show)
    (progn
      (defun /eyecandy/fold-overlay (ov)
        (when (eq 'code (overlay-get ov 'hs))
          (let ((col (save-excursion
                       (move-end-of-line 0)
                       (current-column)))
                (count (count-lines (overlay-start ov) (overlay-end ov))))
            (overlay-put ov 'after-string
                         (format "%s [ %d ] ... "
                                 (make-string (- (window-width) col 32) (string-to-char "."))
                                 count)))))
      (setq hs-set-up-overlay '/eyecandy/fold-overlay)
      (add-hook 'prog-mode-hook #'hs-minor-mode))))
#+END_SRC

The =diminish= package hides minor modes from the modeline.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (require-package 'diminish)
  (diminish 'visual-line-mode)
  (after 'aggressive-indent (diminish 'aggressive-indent-mode))
  (after 'auto-complete (diminish 'auto-complete-mode))
  (after 'autorevert (diminish #'auto-revert-mode))
  (after 'color-identifiers-mode (diminish 'color-identifiers-mode))
  (after 'company (diminish 'company-mode))
  (after 'counsel (diminish #'counsel-mode))
  (after 'eldoc (diminish 'eldoc-mode))
  (after 'elisp-slime-nav (diminish 'elisp-slime-nav-mode))
  (after 'evil-commentary (diminish 'evil-commentary-mode))
  (after 'flycheck (diminish 'flycheck-mode))
  (after 'git-gutter+ (diminish 'git-gutter+-mode))
  (after 'helm-mode (diminish 'helm-mode))
  (after 'hideshow (diminish 'hs-minor-mode))
  (after 'highlight-symbol (diminish 'highlight-symbol-mode))
  (after 'indent-guide (diminish 'indent-guide-mode))
  (after 'ivy (diminish 'ivy-mode))
  (after 'page-break-lines (diminish 'page-break-lines-mode))
  (after 'projectile (diminish 'projectile-mode))
  (after 'smartparens (diminish 'smartparens-mode))
  (after 'undo-tree (diminish 'undo-tree-mode))
  (after 'which-key (diminish 'which-key-mode))
  (after 'yasnippet (diminish 'yas-minor-mode))
#+END_SRC

Configure the preferred modeline package. I could edit the default modeline,
but =smart-mode-line=, my preferred modeline, is very simple already and very
lightweight.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (if (eq dotemacs-eyecandy/mode-line 'sml)
      (progn
        (require-package 'smart-mode-line)
        (setq sml/theme 'dark)
        (setq sml/no-confirm-load-theme t)
        (sml/setup))
    (require-package 'spaceline)
    (require 'spaceline-config)
    (setq spaceline-highlight-face-func #'spaceline-highlight-face-evil-state)
    (set-face-attribute 'spaceline-evil-emacs nil :background "red" :foreground "white")
    (spaceline-spacemacs-theme)
    (spaceline-info-mode)
    (after "helm-autoloads"
           (spaceline-helm-mode)))
#+END_SRC

=prettify-symbols-mode= makes some keywords into their correspondent unicode
characters. For exemple, alpha becomes α, lambda becomes λ and etc...

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (when (fboundp 'global-prettify-symbols-mode)
    (global-prettify-symbols-mode)
    (add-hook 'js2-mode-hook
              (lambda ()
                (push '("function" . 955) prettify-symbols-alist)
                (push '("return" . 8592) prettify-symbols-alist))))
#+END_SRC

These are some eye candy packages. If you're interested in any of them just look
them up on your favorite search engine.

#+BEGIN_SRC emacs-lisp :tangle config/config-eyecandy.el
  (/boot/delayed-init
   (require-package 'color-identifiers-mode)
   (global-color-identifiers-mode)
   (diminish 'color-identifiers-mode))

  (require-package 'highlight-symbol)
  (setq highlight-symbol-idle-delay 0.3)
  (add-hook 'prog-mode-hook 'highlight-symbol-mode)

  (require-package 'highlight-numbers)
  (add-hook 'prog-mode-hook 'highlight-numbers-mode)

  (require-package 'highlight-quoted)
  (add-hook 'prog-mode-hook 'highlight-quoted-mode)

  (require-package 'page-break-lines)
  (global-page-break-lines-mode)

  (require-package 'eval-sexp-fu)
  (require 'eval-sexp-fu)
  (eval-sexp-fu-flash-mode)

  (when (and (display-graphic-p)
           (font-info "all-the-icons"))
    (setq all-the-icons-scale-factor 0.7)
    (setq inhibit-compacting-font-caches t)

    (after 'dired
           (require-package 'all-the-icons-dired)
           (add-hook 'dired-mode-hook #'all-the-icons-dired-mode))

    (after 'ivy
           (require-package 'all-the-icons-ivy)
           (all-the-icons-ivy-setup)))

  (add-hook 'find-file-hook #'hl-line-mode)

  (if (fboundp #'display-line-numbers-mode)
      (add-hook 'find-file-hook #'display-line-numbers-mode)
    (add-hook 'find-file-hook 'linum-mode))

  (provide 'config-eyecandy)
#+END_SRC
